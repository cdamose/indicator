//@version=6
indicator('CRT + CISD + Displacement + SMT', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500, max_bars_back = 4000)

// Explicitly set max_bars_back for key variables
max_bars_back(time, 4000)
max_bars_back(high, 4000)
max_bars_back(low, 4000)
max_bars_back(close, 4000)
max_bars_back(open, 4000)

// Function to convert timeframe to label text
convertTimeFrameLabel(tfString) =>
    switch tfString
        '60' => 'H1'
        '240' => 'H4'
        '360' => 'H6'
        'D' => 'D1'
        'W' => 'W1'
        '1M' => '1M'
        '3M' => '3M'
        '6M' => '6M'
        '12M' => '12M'
        => ''

// Menu inputs
var g_TF = 'CRT Settings' 
// Label display settings
show_eol_labels = input.bool(true, 'ON / OFF', group = g_TF)
label_position = 'Left' //input.string('Center', 'Label Position', options=['Left', 'Center', 'Right'], group = g_TF)
show_hl_text = true
label_size = size.tiny
hllinewidth = input.int(1, 'Line Thickness', minval=1, maxval=4, group = g_TF)
line_style = input.string(line.style_solid, 'Line Style', options=[line.style_solid, line.style_dotted, line.style_dashed], group = g_TF)
var g_TF1 = 'CRT Colors'
// 1 hour TF settings (ENABLED - Essential for 1m-15m analysis)
use_tf1 = input.bool(true, 'H1 ✓', inline = 'TF1', group = g_TF1)
tf1_color = input.color(color.rgb(4, 0, 255), '', inline = 'TF1', group = g_TF1)

// 4 hour TF settings (ENABLED - Essential for 30m-1H analysis)
use_tf2 = input.bool(true, 'H4 ✓', inline = 'TF1', group = g_TF1)
tf2_color = input.color(#045302, '', inline = 'TF1', group = g_TF1)

// 6 hour TF settings
use_tf3 = input.bool(true, 'H6', inline = 'TF1', group = g_TF1)
tf3_color = input.color(#006d21, '', inline = 'TF1', group = g_TF1)

// 1 day TF settings
use_tf4 = input.bool(true, 'D', inline = 'TF2', group = g_TF1)
tf4_color = input.color(#000000, '', inline = 'TF2', group = g_TF1)

// 1 week TF settings
use_tf5 = input.bool(true, 'W', inline = 'TF2', group = g_TF1)
tf5_color = input.color(#fc0303, '', inline = 'TF2', group = g_TF1)

// 1 month TF settings
use_tf6 = input.bool(false, '1M', inline = 'TF3', group = g_TF1)
tf6_color = input.color(#e6a10d, '', inline = 'TF3', group = g_TF1)

// 3 months TF settings
use_tf7 = input.bool(false, '3M', inline = 'TF2', group = g_TF1)
tf7_color = input.color(#e60dd1, '', inline = 'TF2', group = g_TF1)

// 6 months TF settings
use_tf8 = input.bool(false, '6M', inline = 'TF3', group = g_TF1)
tf8_color = input.color(#0dd1e6, '', inline = 'TF3', group = g_TF1)

// 1 year TF settings
use_tf9 = input.bool(false, '12M', inline = 'TF3', group = g_TF1)
tf9_color = input.color(#d1e60d, '', inline = 'TF3', group = g_TF1)

// Line settings
eol_label_offset = 1
// CISD settings
bullishBreakColor = input.color(color.green, "Bullish CISD", inline = "bup")
bearishBreakColor = input.color(color.red, "Bearish CISD", inline = "bep")

bullStr = input.string("+ CISD", " ", tooltip = "Text to display next to the CISD level.", inline = "bup")
bearStr = input.string("- CISD", " ", tooltip = "Text to display next to the CISD level.", inline = "bep")

bullishAlerts = input.bool(false, "Alert?", "When configured via Tradingview, the script will send an alert when the price closes ABOVE the current '+CISD' level", inline = "bup")
bearishAlerts = input.bool(false, "Alert?", "When configured via Tradingview, the script will send an alert when the price closes BELOW the current '+CISD' level", inline = "bep")

lineWidth = input.int(1, "Line Thickness", minval=1, maxval=5)
lookAheadBars = input.int(5, "Bar Offset", minval=1, maxval = 5)
styleOption = input.string("Solid (─)", title="Line Style",
     options=["Solid (─)", "Dotted (┈)", "Dashed (╌)"])
keepLevels = input.bool(false, "History of old CISD levels")



// Timeframes
tf1 = '60' // 1 hour
tf2 = '240' // 4 hours
tf3 = '360' // 6 hours
tf4 = 'D' // day
tf5 = 'W' // week
tf6 = '1M' // month
tf7 = '3M' // 3 months
tf8 = '6M' // 6 months
tf9 = '12M' // 1 year

// Function to process data for a given timeframe
process_tf(tf) =>
    var float rangeHigh = na
    var float rangeLow = na
    var int rangeStart = 0
    var bool inConsolidation = true
    var bool bullishTouch = false
    var bool bearishTouch = false
    var bool justFormed = false
    
    // Last values for the previous bar
    var float prevRangeHigh = na
    var float prevRangeLow = na

    // Get data from the current timeframe
    [tfOpen, tfHigh, tfLow, tfClose, tfTime] = request.security(syminfo.tickerid, tf, [open, high, low, close, time], barmerge.gaps_off, barmerge.lookahead_on)

    // Determine a new bar on the selected timeframe
    newBar = ta.change(tfTime) != 0
    
    // Reset flag on each bar
    justFormed := false 

    if newBar
        // Check if price has exited the current consolidation
        upControl = tfClose > rangeHigh and tfOpen > rangeHigh and bar_index - rangeStart > 1 and bar_index - rangeStart <= 250
        downControl = tfClose < rangeLow and tfOpen < rangeLow and bar_index - rangeStart > 1 and bar_index - rangeStart <= 250

        if upControl or downControl
            inConsolidation := false

        // Check if we are within the current CRT range
        hasValidRange = not na(rangeHigh) and not na(rangeLow)
        isWithinRange = hasValidRange and inConsolidation and 
                       tfOpen > tfClose ? (tfClose <= rangeHigh and tfClose >= rangeLow and tfOpen <= rangeHigh and tfOpen >= rangeLow) : (tfOpen <= rangeHigh and tfOpen >= rangeLow and tfClose <= rangeHigh and tfClose >= rangeLow)
        
        // If we are within the range, continue to use the current CRT
        if isWithinRange and bar_index > 1
            // Do nothing, keep current rangeStart value
            int a = 0  // Empty operation to maintain if-else structure
        else
            // IMPORTANT: Save previous values before creating a new CRT
            prevRangeHigh := rangeHigh
            prevRangeLow := rangeLow
            
            // Form a new CRT
            rangeHigh := tfHigh
            rangeLow := tfLow
            rangeStart := bar_index  // Formation point - CURRENT bar
            inConsolidation := true
            justFormed := true  // Set flag that CRT has just formed
        
        // If consolidation expired by time or became invalid
        if not inConsolidation and (bar_index - rangeStart > 250 or bar_index - rangeStart < 1)
            // Save previous values
            prevRangeHigh := rangeHigh
            prevRangeLow := rangeLow
            
            // Create a new CRT
            rangeHigh := tfHigh
            rangeLow := tfLow
            rangeStart := bar_index  // Again, CURRENT bar
            inConsolidation := true
            justFormed := true  // Set flag
        
        // Reset touch flags on a new bar
        bullishTouch := false
        bearishTouch := false

    // Check for level touches on the current bar
    if inConsolidation and not na(rangeHigh) and not na(rangeLow)
        bullishWickTouch = low < rangeLow and close > rangeLow and high < rangeHigh
        bullishBodyTouch = open < rangeLow and close > rangeLow
        bearishWickTouch = high > rangeHigh and close < rangeHigh and low > rangeLow
        bearishBodyTouch = open > rangeHigh and close < rangeHigh

        bullishTouch := bullishWickTouch or bullishBodyTouch
        bearishTouch := bearishWickTouch or bearishBodyTouch

    // Return all necessary data
    [rangeHigh, rangeLow, rangeStart, inConsolidation, newBar, bullishTouch, bearishTouch, justFormed, prevRangeHigh, prevRangeLow]

// Function to check timeframe visibility
is_higher_tf_visible(tf) =>
    tf_sec = request.security(syminfo.tickerid, tf, timeframe.in_seconds(timeframe.period))
    timeframe.in_seconds(timeframe.period) <= tf_sec

// Determine which timeframes are visible
hide_tf1 = not is_higher_tf_visible(tf1)
hide_tf2 = not is_higher_tf_visible(tf2)
hide_tf3 = not is_higher_tf_visible(tf3)
hide_tf4 = not is_higher_tf_visible(tf4)
hide_tf5 = not is_higher_tf_visible(tf5)
hide_tf6 = not is_higher_tf_visible(tf6)
hide_tf7 = not is_higher_tf_visible(tf7)
hide_tf8 = not is_higher_tf_visible(tf8)
hide_tf9 = not is_higher_tf_visible(tf9)

// Get data for all timeframes
[high1, low1, start1, inRange1, newBar1, bullishTouch1, bearishTouch1, justFormed1, prevHigh1, prevLow1] = process_tf(tf1)
[high2, low2, start2, inRange2, newBar2, bullishTouch2, bearishTouch2, justFormed2, prevHigh2, prevLow2] = process_tf(tf2)
[high3, low3, start3, inRange3, newBar3, bullishTouch3, bearishTouch3, justFormed3, prevHigh3, prevLow3] = process_tf(tf3)
[high4, low4, start4, inRange4, newBar4, bullishTouch4, bearishTouch4, justFormed4, prevHigh4, prevLow4] = process_tf(tf4)
[high5, low5, start5, inRange5, newBar5, bullishTouch5, bearishTouch5, justFormed5, prevHigh5, prevLow5] = process_tf(tf5)
[high6, low6, start6, inRange6, newBar6, bullishTouch6, bearishTouch6, justFormed6, prevHigh6, prevLow6] = process_tf(tf6)
[high7, low7, start7, inRange7, newBar7, bullishTouch7, bearishTouch7, justFormed7, prevHigh7, prevLow7] = process_tf(tf7)
[high8, low8, start8, inRange8, newBar8, bullishTouch8, bearishTouch8, justFormed8, prevHigh8, prevLow8] = process_tf(tf8)
[high9, low9, start9, inRange9, newBar9, bullishTouch9, bearishTouch9, justFormed9, prevHigh9, prevLow9] = process_tf(tf9)

// Completely refactored function for drawing lines
plot_lines(tfColor, highValue, lowValue, start, inRange, newBar, justFormed, tfName, offset) =>
    var line highLine = na
    var line lowLine = na
    var label highLabel = na
    var label lowLabel = na
    var int formationBar = na
    var float highLineValue = na
    var float lowLineValue = na
    
    // New line logic - create a new line only if formation occurred and only from the current bar
    if justFormed and inRange
        // Delete previous lines and labels (if any)
        if not na(highLine)
            line.delete(highLine)
        if not na(lowLine)
            line.delete(lowLine)
        if not na(highLabel)
            label.delete(highLabel)
        if not na(lowLabel)
            label.delete(lowLabel)
        
        // Remember current bar and level values
        formationBar := bar_index
        highLineValue := highValue
        lowLineValue := lowValue
        
        // Create new lines from the current bar to the current bar (initially a point)
        highLine := line.new(x1=bar_index, y1=highValue, x2=bar_index, y2=highValue, color=tfColor, width=hllinewidth, style=line_style)
        lowLine := line.new(x1=bar_index, y1=lowValue, x2=bar_index, y2=lowValue, color=tfColor, width=hllinewidth, style=line_style)
        
        // Create labels
        if show_eol_labels
            labelX = bar_index + offset
            
            highText = show_hl_text ? convertTimeFrameLabel(tfName) + ' H' : convertTimeFrameLabel(tfName)
            lowText = show_hl_text ? convertTimeFrameLabel(tfName) + ' L' : convertTimeFrameLabel(tfName)
            
            labelStyle = label_position == 'Center' ? label.style_label_center : label_position == 'Left' ? label.style_label_left : label.style_label_right
            
            highLabel := label.new(x=labelX, y=highValue, text=highText, color=tfColor, textcolor=color.white, style=labelStyle, size=label_size)
            lowLabel := label.new(x=labelX, y=lowValue, text=lowText, color=tfColor, textcolor=color.white, style=labelStyle, size=label_size)
    
    // Continuously update only the right end of the line to the current bar
    if not na(highLine) and inRange and not na(formationBar) and not na(highLineValue) and not na(lowLineValue)
        // Update only the right end (x2) of the line, the left (x1) always remains at the formation point
        line.set_x2(highLine, bar_index)
        line.set_y2(highLine, highLineValue)
        line.set_x2(lowLine, bar_index)
        line.set_y2(lowLine, lowLineValue)
        
        // Update label positions
        if show_eol_labels
            labelX = bar_index + offset  // Always to the right of the current bar
            
            if not na(highLabel)
                label.set_x(highLabel, labelX)
                label.set_y(highLabel, highLineValue)
            if not na(lowLabel)
                label.set_x(lowLabel, labelX)
                label.set_y(lowLabel, lowLineValue)

// Plot lines for selected timeframes
if use_tf1 and not hide_tf1
    plot_lines(tf1_color, high1, low1, start1, inRange1, newBar1, justFormed1, tf1, 3)

if use_tf2 and not hide_tf2
    plot_lines(tf2_color, high2, low2, start2, inRange2, newBar2, justFormed2, tf2, 3) // Corrected justForm2 to justFormed2

if use_tf3 and not hide_tf3
    plot_lines(tf3_color, high3, low3, start3, inRange3, newBar3, justFormed3, tf3, 3)

if use_tf4 and not hide_tf4
    plot_lines(tf4_color, high4, low4, start4, inRange4, newBar4, justFormed4, tf4, 3)

if use_tf5 and not hide_tf5
    plot_lines(tf5_color, high5, low5, start5, inRange5, newBar5, justFormed5, tf5, 3)

if use_tf6 and not hide_tf6
    plot_lines(tf6_color, high6, low6, start6, inRange6, newBar6, justFormed6, tf6, 3)

if use_tf7 and not hide_tf7
    plot_lines(tf7_color, high7, low7, start7, inRange7, newBar7, justFormed7, tf7, 3)

if use_tf8 and not hide_tf8
    plot_lines(tf8_color, high8, low8, start8, inRange8, newBar8, justFormed8, tf8, 3)

if use_tf9 and not hide_tf9
    plot_lines(tf9_color, high9, low9, start9, inRange9, newBar9, justFormed9, tf9, 3)

// Alerts
alertcondition(bullishTouch1, title = 'H1 Bullish Touch', message = 'Price touched H1 Low')
alertcondition(bearishTouch1, title = 'H1 Bearish Touch', message = 'Price touched H1 High')

alertcondition(bullishTouch2, title = 'H4 Bullish Touch', message = 'Price touched H4 Low')
alertcondition(bearishTouch2, title = 'H4 Bearish Touch', message = 'Price touched H4 High')

alertcondition(bullishTouch3, title = 'H6 Bullish Touch', message = 'Price touched H6 Low')
alertcondition(bearishTouch3, title = 'H6 Bearish Touch', message = 'Price touched H6 High')

alertcondition(bullishTouch4, title = 'D Bullish Touch', message = 'Price touched D Low')
alertcondition(bearishTouch4, title = 'D Bearish Touch', message = 'Price touched D High')

alertcondition(bullishTouch5, title = 'W Bullish Touch', message = 'Price touched W Low')
alertcondition(bearishTouch5, title = 'W Bearish Touch', message = 'Price touched W High')

alertcondition(bullishTouch6, title = '1M Bullish Touch', message = 'Price touched 1M Low')
alertcondition(bearishTouch6, title = '1M Bearish Touch', message = 'Price touched 1M High')

alertcondition(bullishTouch7, title = '3M Bullish Touch', message = 'Price touched 3M Low')
alertcondition(bearishTouch7, title = '3M Bearish Touch', message = 'Price touched 3M High')

alertcondition(bullishTouch8, title = '6M Bullish Touch', message = 'Price touched 6M Low')
alertcondition(bearishTouch8, title = '6M Bearish Touch', message = 'Price touched 6M High')

alertcondition(bullishTouch9, title = '12M Bullish Touch', message = 'Price touched 12M Low')
alertcondition(bearishTouch9, title = '12M Bearish Touch', message = 'Price touched 12M High')

// CISD /* function */
 
type MarketStructure
    float topPrice
    float bottomPrice
    bool isBullish

type cisd
    line level
    label txt
    bool completed

lineStyle = styleOption == "Dotted (┈)" ? line.style_dotted :
     styleOption == "Dashed (╌)" ? line.style_dashed :
         line.style_solid

// Variable Declarations
var line lastTopLine = na
var line lastBottomLine = na
var MarketStructure currentStructure = MarketStructure.new(0, 0, false)

var cisdLevelsBu = array.new<cisd>()
var cisdLevelsBe = array.new<cisd>()

var bool isBullishPullback = false
var bool isBearishPullback = false

var float potentialTopPrice = na
var float potentialBottomPrice = na

var int bullishBreakIndex = na
var int bearishBreakIndex = na

var float bullishChangeLevel = na
var float bearishChangeLevel = na

var bool currentState = false

gettablePos(pos) =>
    switch pos
        "Top Right" => position.top_right
        "Bottom Right" => position.bottom_right
        "Middle Right" => position.middle_right
        "Bottom Center" => position.bottom_center
        "Middle Left" => position.bottom_left


// Pullback Detection
bearishPullbackDetected = close[1] > open[1]
bullishPullbackDetected = close[1] < open[1]

// Bearish Pullback Logic
if bearishPullbackDetected and not isBearishPullback
    isBearishPullback := true
    potentialTopPrice := open[1]
    bullishBreakIndex := bar_index[1]

// Bullish Pullback Logic
if bullishPullbackDetected and not isBullishPullback
    isBullishPullback := true
    potentialBottomPrice := open[1]
    bearishBreakIndex := bar_index[1]

// Update Potential Levels During Pullbacks
if isBullishPullback
    if open < potentialBottomPrice
        potentialBottomPrice := open
        bearishBreakIndex := bar_index
    if (close < open) and (open > potentialBottomPrice)
        potentialBottomPrice := open
        bearishBreakIndex := bar_index     

if isBearishPullback
    if open > potentialTopPrice
        potentialTopPrice := open
        bullishBreakIndex := bar_index
    if (close > open) and open < potentialTopPrice
        potentialTopPrice := open
        bullishBreakIndex := bar_index      

// Structure Updates - Bearish Break
if low < currentStructure.bottomPrice
    currentStructure.bottomPrice := low
    currentStructure.isBullish := false
    
    if isBearishPullback and (bar_index-bullishBreakIndex != 0)
        currentStructure.topPrice := math.max(high[bar_index-bullishBreakIndex],high[bar_index-bullishBreakIndex+1])
        isBearishPullback := false
        bearishLine = line.new(bullishBreakIndex, potentialTopPrice, bar_index + lookAheadBars, potentialTopPrice, color=bullishBreakColor, width=lineWidth, style = lineStyle)
        bearishLabel = label.new(bar_index + lookAheadBars, potentialTopPrice, bullStr, color=color.new(color.white,100), textcolor=bullishBreakColor, style=label.style_label_left, text_font_family = font.family_default, size = size.small, text_formatting = text.format_italic)

        b = cisd.new(bearishLine, bearishLabel, false)
        cisdLevelsBe.push(b)
    else if close[1] > open[1] and close < open
        currentStructure.topPrice := high[1]

        isBearishPullback := false
        bearishLine = line.new(bullishBreakIndex, potentialTopPrice, bar_index + lookAheadBars, potentialTopPrice, color=bullishBreakColor, width=lineWidth, style = lineStyle)
        bearishLabel = label.new(bar_index + lookAheadBars, potentialTopPrice, bullStr, color=color.new(color.white,100), textcolor=bullishBreakColor, style=label.style_label_left, text_font_family = font.family_default, size = size.small, text_formatting = text.format_italic)

        b = cisd.new(bearishLine, bearishLabel, false)
        cisdLevelsBe.push(b)

// Structure Updates - Bullish Break
if high > currentStructure.topPrice
    currentStructure.isBullish := true
    currentStructure.topPrice := high
    
    if isBullishPullback and (bar_index-bearishBreakIndex != 0)
        currentStructure.bottomPrice := math.min(low[bar_index-bearishBreakIndex],low[bar_index-bearishBreakIndex+1])
        isBullishPullback := false

        bullishLine = line.new(bearishBreakIndex, potentialBottomPrice, bar_index + lookAheadBars, potentialBottomPrice, color=bearishBreakColor, width=lineWidth, style = lineStyle)
        bullishLabel = label.new(bar_index + lookAheadBars, potentialBottomPrice, bearStr, color=color.new(color.white,100), textcolor=bearishBreakColor, style=label.style_label_left, text_font_family = font.family_default, size = size.small, text_formatting = text.format_italic)

        bu = cisd.new(bullishLine, bullishLabel, false)
        cisdLevelsBu.push(bu)
    else if close[1] < open[1] and close > open
        currentStructure.bottomPrice := low[1]

        isBullishPullback := false

        bullishLine = line.new(bearishBreakIndex, potentialBottomPrice, bar_index + lookAheadBars, potentialBottomPrice, color=bearishBreakColor, width=lineWidth, style = lineStyle)
        bullishLabel = label.new(bar_index + lookAheadBars, potentialBottomPrice, bearStr, color=color.new(color.white,100), textcolor=bearishBreakColor, style=label.style_label_left, text_font_family = font.family_default, size = size.small, text_formatting = text.format_italic)

        bu = cisd.new(bullishLine, bullishLabel, false)
        cisdLevelsBu.push(bu)


if array.size(cisdLevelsBu) > 1 and not keepLevels
    latest = array.shift(cisdLevelsBu)
    line.delete(latest.level)
    label.delete(latest.txt)

if array.size(cisdLevelsBe) > 1 and not keepLevels
    latest = array.shift(cisdLevelsBe)
    line.delete(latest.level)
    label.delete(latest.txt)

if array.size(cisdLevelsBu) >= 1
    latest = array.get(cisdLevelsBu,0)
    if not (close < latest.level.get_y2()) and not latest.completed
        line.set_x2(latest.level, bar_index+lookAheadBars)
        label.set_x(latest.txt, bar_index+lookAheadBars)
    if close < latest.level.get_y2() and not latest.completed
        latest.completed := true
        alert("Bearish CISD Formed")

        bearishLine = line.new(bullishBreakIndex, potentialTopPrice, bar_index + lookAheadBars, potentialTopPrice, color=bullishBreakColor, width=lineWidth, style = lineStyle)
        bearishLabel = label.new(bar_index + lookAheadBars, potentialTopPrice, bullStr, color=color.new(color.white,100), textcolor=bullishBreakColor, style=label.style_label_left, text_font_family = font.family_monospace, size = size.small, text_formatting = text.format_italic)

        b = cisd.new(bearishLine, bearishLabel, false)
        cisdLevelsBe.push(b)

        currentState := false


if array.size(cisdLevelsBe) >= 1 and not keepLevels
    latest = array.get(cisdLevelsBe,0)
    if not (close > latest.level.get_y2()) and not latest.completed
        line.set_x2(latest.level, bar_index+lookAheadBars)
        label.set_x(latest.txt, bar_index+lookAheadBars)
    if close > latest.level.get_y2() and not latest.completed
        latest.completed := true
        alert("Bullish CISD Formed")

        bullishLine = line.new(bearishBreakIndex, potentialBottomPrice, bar_index + lookAheadBars, potentialBottomPrice, color=bearishBreakColor, width=lineWidth, style = lineStyle)
        bullishLabel = label.new(bar_index + lookAheadBars, potentialBottomPrice, bearStr, color=color.new(color.white,100), textcolor=bearishBreakColor, style=label.style_label_left, text_font_family = font.family_monospace, size = size.small, text_formatting = text.format_italic)

        bu = cisd.new(bullishLine, bullishLabel, false)
        cisdLevelsBu.push(bu)

        currentState := true

// FVG DISP
//+------------------------------------------------------------------------------------------------------------+//
//+--- ICT Displacement FVG Only                                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//
type Imbalance_Settings
    bool show
    color color_bull
    color color_bear
    bool mitigated_show
    string mitigated_type
    color mitigated_color_bull
    color mitigated_color_bear
    bool show_lines
    string open_style
    int open_size
    string close_style
    int close_size
    bool fill
    int fill_percent

    int max_count

type Box
    line open
    line close
    linefill fill

type Imbalance
    int open_time
    int close_time
    float open
    float middle
    float close
    bool mitigated
    int mitigated_time
    bool isbullish
    Box box

type ImbalanceStructure
    string type
    array<Imbalance> imbalance
    Imbalance_Settings settings

type Helper
    string name = 'Helper'

//+------------------------------------------------------------------------------------------------------------+//
//+--- Settings                                                                                             ---+//
//+------------------------------------------------------------------------------------------------------------+//
main_group = 'Main Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'
FVG_Group = 'Displacement Fair Value Gap ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'
displacement_group = 'Displacement Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'

// Main Settings
enable_indicator = input.bool(true, 'Enable Indicator', group = main_group)

// Displacement Settings
displacement_show = input.bool(true, 'Highlight Displacement Candles', group = displacement_group)
displacement_length = input.int(100, minval = 1, title = 'Use last X bars to calculate', group = displacement_group)
displacement_factor = input.int(2, options = [1, 2, 3, 4], title = 'Displacement Strength', group = displacement_group)
displacement_bull = input.color(#bae3c5, 'Bull Displacement Color', group = displacement_group)
displacement_bear = input.color(#ffc2c2, 'Bear Displacement Color', group = displacement_group)

// FVG Settings
Imbalance_Settings FVG_Settings = Imbalance_Settings.new()

FVG_Settings.show := input.bool(true, 'Show Displacement FVG', group = FVG_Group)
FVG_Settings.color_bull := input.color(color.new(#388e3c, 0), 'Bull FVG Color', group = FVG_Group)
FVG_Settings.color_bear := input.color(color.new(#1848cc, 0), 'Bear FVG Color', group = FVG_Group)

FVG_Settings.mitigated_show := input.bool(true, 'Show Mitigated FVG', group = FVG_Group)
FVG_Settings.mitigated_color_bull := input.color(color.new(color.gray, 85), 'Mitigated Bull Color', group = FVG_Group)
FVG_Settings.mitigated_color_bear := input.color(color.new(color.gray, 85), 'Mitigated Bear Color', group = FVG_Group)
FVG_Settings.mitigated_type := input.string('Wick filled', 'Mitigation Type', options = ['None', 'Wick Touched', 'Wick filled', 'Body filled', 'Wick filled half', 'Body filled half'], group = FVG_Group)

FVG_Settings.show_lines := input.bool(true, 'Show FVG Lines', group = FVG_Group)
FVG_Settings.open_style := input.string('⎯⎯⎯', 'FVG Line Style', options = ['None', '⎯⎯⎯', '----', '····'], group = FVG_Group)
FVG_Settings.open_size := input.int(1, 'FVG Line Size', options = [1, 2, 3, 4], group = FVG_Group)

FVG_Settings.close_style := FVG_Settings.open_style
FVG_Settings.close_size := FVG_Settings.open_size



FVG_Settings.fill := input.bool(true, 'Fill Background', group = FVG_Group)
FVG_Settings.fill_percent := input.int(90, 'Background Transparency', options = [98, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50], group = FVG_Group)

FVG_Settings.max_count := input.int(20, 'Maximum FVG Count', group = FVG_Group)

//+------------------------------------------------------------------------------------------------------------+//
//+--- Variables                                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//
color color_transparent = #ffffff00
Helper helper = Helper.new()

var ImbalanceStructure FVGs = ImbalanceStructure.new()
var array<Imbalance> imbalance_array = array.new<Imbalance>()
FVGs.type := "FVG"
FVGs.imbalance := imbalance_array
FVGs.settings := FVG_Settings

// Displacement calculation
body = math.abs(open - close)
std = ta.stdev(math.abs(open - close), displacement_length)

//+------------------------------------------------------------------------------------------------------------+//
//+--- Functions                                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//
f_highlightDisplacement() =>
    if barstate.isconfirmed
        candle_range = math.abs(open[1] - close[1])
        fvg = close[1] > open[1] ? high[2] < low : low[2] > high
        candle_range > std[1] * displacement_factor and fvg

displaced = f_highlightDisplacement()

//+------------------------------------------------------------------------------------------------------------+//
//+--- Methods                                                                                              ---+//
//+------------------------------------------------------------------------------------------------------------+//
method LineStyle(Helper helper, string style) =>
    helper.name := style
    out = switch style
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid
    out

method clear(Imbalance imb) =>
    if not na(imb.box)
        line.delete(imb.box.open)
        line.delete(imb.box.close)
        linefill.delete(imb.box.fill)
        imb.box := na

method render(ImbalanceStructure IS) =>
    if IS.settings.show
        for imb in IS.imbalance
            color c = na
            int buffer = 0

            if imb.mitigated
                buffer := imb.mitigated ? imb.mitigated_time : time + (time - time[1]) * 5
                c := imb.isbullish ? IS.settings.mitigated_color_bull : IS.settings.mitigated_color_bear
            else
                buffer := time + (time - time[1]) * 5
                c := imb.isbullish ? IS.settings.color_bull : IS.settings.color_bear

            if na(imb.box)
                imb.box := Box.new()
                
                // Create lines only if style is not "None" and show_lines is enabled
                if IS.settings.show_lines and IS.settings.open_style != "None"
                    imb.box.open := line.new(imb.open_time, imb.open, buffer, imb.open, xloc = xloc.bar_time, style = helper.LineStyle(IS.settings.open_style), color = c, width = IS.settings.open_size)
                    imb.box.close := line.new(imb.open_time, imb.close, buffer, imb.close, xloc = xloc.bar_time, style = helper.LineStyle(IS.settings.close_style), color = c, width = IS.settings.close_size)

                // Fill works independently - can show background even without lines
                if IS.settings.fill
                    if IS.settings.open_style != "None" and IS.settings.show_lines
                        // Use lines for fill if they exist
                        imb.box.fill := linefill.new(imb.box.open, imb.box.close, color.new(c, IS.settings.fill_percent))
                    else
                        // Create invisible lines just for fill when style is "None"
                        imb.box.open := line.new(imb.open_time, imb.open, buffer, imb.open, xloc = xloc.bar_time, color = color_transparent)
                        imb.box.close := line.new(imb.open_time, imb.close, buffer, imb.close, xloc = xloc.bar_time, color = color_transparent)
                        imb.box.fill := linefill.new(imb.box.open, imb.box.close, color.new(c, IS.settings.fill_percent))
            else
                // Update existing FVG
                if IS.settings.show_lines and IS.settings.open_style != "None"
                    if not na(imb.box.open)
                        line.set_color(imb.box.open, c)
                        line.set_x2(imb.box.open, buffer)
                    if not na(imb.box.close)
                        line.set_color(imb.box.close, c)
                        line.set_y1(imb.box.close, imb.close)
                        line.set_xy2(imb.box.close, buffer, imb.close)
                
                // Update fill - works for both visible and invisible lines
                if IS.settings.open_style == "None" and IS.settings.fill
                    if not na(imb.box.open)
                        line.set_x2(imb.box.open, buffer)
                    if not na(imb.box.close)
                        line.set_y1(imb.box.close, imb.close)
                        line.set_xy2(imb.box.close, buffer, imb.close)

            if imb.mitigated and not IS.settings.mitigated_show
                imb.clear()
    IS

method AddImbalance(ImbalanceStructure IS, float o, float c, int o_time, int c_time) =>
    Imbalance imb = Imbalance.new()
    imb.open_time := o_time
    imb.close_time := c_time
    imb.open := o
    imb.middle := (o + c) / 2
    imb.close := c
    imb.isbullish := o < c

    IS.imbalance.unshift(imb)

    if IS.imbalance.size() > IS.settings.max_count
        temp = IS.imbalance.pop()
        temp.clear()
    IS

method CheckMitigated(ImbalanceStructure IS) =>
    for imb in IS.imbalance
        if not imb.mitigated
            switch IS.settings.mitigated_type
                'None' => 
                    imb.mitigated := false
                'Wick Touched' => 
                    imb.mitigated := imb.isbullish ? low < imb.close : high > imb.close
                'Wick filled' => 
                    imb.mitigated := imb.isbullish ? low <= imb.open : high >= imb.open
                'Body filled' => 
                    imb.mitigated := imb.isbullish ? math.min(open, close) <= imb.open : math.max(open, close) >= imb.open
                'Wick filled half' => 
                    imb.mitigated := imb.isbullish ? low <= imb.middle : high >= imb.middle
                'Body filled half' => 
                    imb.mitigated := imb.isbullish ? math.min(open, close) <= imb.middle : math.max(open, close) >= imb.middle
            if imb.mitigated
                imb.mitigated_time := time
    IS

method FindDisplacementFVG(ImbalanceStructure IS) =>
    // Check for FVG formation
    FVG = high < low[2] or low > high[2]
    Gap = low > high[1] or high < low[1]
    
    // Only process FVG if there's displacement
    if FVG and not Gap and not Gap[1] and displaced
        float o = 0
        float c = 0
        
        if low > high[2]  // Bullish FVG
            c := low
            o := high[2]
        
        if high < low[2]  // Bearish FVG
            c := high
            o := low[2]
        
        IS.AddImbalance(o, c, time[1], time)
    IS

//+------------------------------------------------------------------------------------------------------------+//
//+--- Displacement Highlighting                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//
color candle_color = open[1] < close[1] ? displacement_bull : displacement_bear
barcolor(displaced and displacement_show and enable_indicator ? candle_color : na, offset = -1)

//+------------------------------------------------------------------------------------------------------------+//
//+--- Main Execution (FVG DISP)                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//
if enable_indicator and last_bar_index - bar_index < 1000
    // Call FindDisplacementFVG on each bar for consistency
    FVGs.FindDisplacementFVG()

    FVGs.CheckMitigated()

    if barstate.islast
        FVGs.render()

// SMT (Smart Money Technique) from all in one.txt
// SMT Inputs
show_smt_table = input.bool(defval= true , title= "Show SMT table"  ,group="SMT Settings",inline="1")
show_swe_table = input.bool(defval= true , title= "Show Sweep table",group="SMT Settings",inline="1")
smt_on_chart   = input.bool(defval= true , title= "Show SMTs on chart--",group="SMT Settings",inline="smt")
style_smt      = input.string(defval=line.style_solid,title= "Style:",options=[line.style_solid,line.style_dotted,line.style_dashed ],group="SMT Settings",inline= "smt")
sweep_on_chart = input.bool(defval= true , title= "Show Sweeps on chart--",group="SMT Settings",inline="swe")
style_swp      = input.string(defval=line.style_dotted,title= "Style:",options=[line.style_solid,line.style_dotted,line.style_dashed ],group="SMT Settings",inline= "swe")

alert1_on = input.bool(defval= false , title= "Activate Alert (SMT + Sweep)",group="SMT Alerts",tooltip ="for selected HTFs (SMT + Sweep)")
alert2_on = input.bool(defval= false , title= "Activate Alert (Sweep + Sweep)",group="SMT Alerts",tooltip ="Both asset sweep")
bualert = input.bool(defval= true  , title= "Bullish Alerts" ,group="SMT Alerts",inline="al")
bealert = input.bool(defval= true  , title= "Bearish Alerts" ,group="SMT Alerts",inline="al")

g_smt_tf = "SMT Timeframes (Auto-Optimized)"
// TF1: 1H - For 1m-15m chart analysis (ENABLED)
smt_tfok1 = input.bool(defval=true,title="1H (for 1m-15m charts)",group = g_smt_tf,inline="1")
smt_tf1 = input.timeframe(defval= "60",title = "TF1:",group =g_smt_tf,inline="1")
// TF2: 4H - For 30m-1H chart analysis (ENABLED)
smt_tfok2 = input.bool(defval=true,title="4H (for 30m-1H charts)",group = g_smt_tf,inline="2")
smt_tf2 = input.timeframe(defval= "240",title = "TF2:",group =g_smt_tf,inline="2")
// TF3: Weekly - For higher timeframe analysis (OPTIONAL)
smt_tfok3 = input.bool(defval=false,title="Weekly (optional)",group = g_smt_tf,inline="3")
smt_tf3 = input.timeframe(defval= "1W",title = "TF3:",group =g_smt_tf,inline="3")
// TF4: Daily - For 2H-4H chart analysis (ENABLED)
smt_tfok4 = input.bool(defval=true,title="Daily (for 2H-4H charts)",group = g_smt_tf,inline="4")
smt_tf4 = input.timeframe(defval= "1D",title = "TF4:",group =g_smt_tf,inline="4")
// TF5: 12H - For daily chart analysis (ENABLED)
smt_tfok5 = input.bool(defval=true,title="12H (for daily charts)",group = g_smt_tf,inline="5")
smt_tf5 = input.timeframe(defval= "720",title = "TF5:",group =g_smt_tf,inline="5")
// Additional HTF timeframes (institutional focus only)
smt_tfok6 = input.bool(defval=false,title="2H Analysis (optional)",group = g_smt_tf,inline="6")
smt_tf6 = input.timeframe(defval= "120",title = "TF6:",group =g_smt_tf,inline="6")
smt_tfok7 = input.bool(defval=false,title="6H Analysis (optional)",group = g_smt_tf,inline="7")
smt_tf7 = input.timeframe(defval= "360",title = "TF7:",group =g_smt_tf,inline="7")
smt_tfok8 = input.bool(defval=false,title="Monthly Analysis (optional)",group = g_smt_tf,inline="8")
smt_tf8 = input.timeframe(defval= "1M",title = "TF8:",group =g_smt_tf,inline="8")
smt_tfok9 = input.bool(defval=false,title="3M Analysis (optional)",group = g_smt_tf,inline="9")
smt_tf9 = input.timeframe(defval= "3M",title = "TF9:",group =g_smt_tf,inline="9")

// Entry Score Settings
g_entry_score = "Entry Score Configuration"
min_entry_score = input.float(defval=4.0, title="Minimum Entry Score", minval=1.0, maxval=10.0, step=0.5, group=g_entry_score, tooltip="Minimum total points required for trade entry")

// Signal Point Values
smt_points = input.float(defval=3.0, title="SMT Confirmation", minval=0.5, maxval=5.0, step=0.5, group=g_entry_score, inline="points1", tooltip="Points for SMT divergence confirmation")
double_sweep_points = input.float(defval=2.5, title="Double Sweep", minval=0.5, maxval=5.0, step=0.5, group=g_entry_score, inline="points1", tooltip="Points for both assets sweeping")

crt_touch_points = input.float(defval=2.0, title="CRT Touch/Zone", minval=0.5, maxval=5.0, step=0.5, group=g_entry_score, inline="points2", tooltip="Points for price at CRT boundaries")
cisd_points = input.float(defval=1.5, title="CISD Break", minval=0.5, maxval=5.0, step=0.5, group=g_entry_score, inline="points2", tooltip="Points for CISD level break")

single_sweep_points = input.float(defval=1.0, title="Single Sweep", minval=0.5, maxval=5.0, step=0.5, group=g_entry_score, inline="points3", tooltip="Points for single asset sweep")

// Entry Score Display
show_score_table = input.bool(defval=true, title="Show Score Breakdown", group=g_entry_score, tooltip="Display detailed score breakdown in table")
score_table_position = input.string(defval="Top Right", title="Score Table Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=g_entry_score)

// HTF Candles (Exact copy from fractal_model_indicator.pine)
g_htf_candles = "HTF Candle"

// HTF Selection - Auto or Custom
htf_mode = input.string("Auto", "HTF Mode", options=["Auto", "Custom"], group=g_htf_candles)
custom_htf = input.timeframe("1W", "Custom Timeframe", group=g_htf_candles)

show_htf_candles = input.bool(true, "Show HTF", group=g_htf_candles)
htf_max_display = input.int(4, "Max Display", group=g_htf_candles)

// HTF Colors (exact match)
htf_bull_body = input.color(color.new(#8ABF91, 10), "Body  ", inline="body", group=g_htf_candles)
htf_bear_body = input.color(color.new(#E08C89, 10), "", inline="body", group=g_htf_candles)
htf_bull_border = input.color(color.new(#8ABF91, 10), "Borders", inline="borders", group=g_htf_candles)
htf_bear_border = input.color(color.new(#E08C89, 10), "", inline="borders", group=g_htf_candles)
htf_bull_wick = input.color(color.new(#8ABF91, 10), "Wick  ", inline="wick", group=g_htf_candles)
htf_bear_wick = input.color(color.new(#E08C89, 10), "", inline="wick", group=g_htf_candles)

// HTF Settings (exact match)
htf_offset = input.int(20, "padding from current candles", minval = 1, group=g_htf_candles)
htf_buffer = input.int(1, "space between candles", minval = 1, maxval = 4, group=g_htf_candles)
htf_htf_buffer = input.int(5, "space between Higher Timeframes", minval = 1, maxval = 10, group=g_htf_candles)
htf_width = input.int(1, "Candle Width", minval = 1, maxval = 4, group=g_htf_candles)*2

// HTF Labels (exact match)
htf_label_show = input.bool(true, "HTF Label           ", inline="HTFlabel", group=g_htf_candles)
htf_label_color = input.color(color.black, "", inline='HTFlabel', group=g_htf_candles)
htf_label_size = input.string(size.normal, "", [size.tiny, size.small, size.normal, size.large, size.huge], inline="HTFlabel", group=g_htf_candles)

// HTF Timer (exact match)
htf_timer_show = input.bool(true, "Remaining time      ", inline="timer", group=g_htf_candles)
htf_timer_color = input.color(color.black, "", inline='timer', group=g_htf_candles)
htf_timer_size = input.string(size.normal, "", [size.tiny, size.small, size.normal, size.large, size.huge], inline="timer", group=g_htf_candles)

//Correlated pairs
g_corr_pairs = "Correlated pairs"
ok1 = input.bool(defval=true,title="",group = g_corr_pairs,inline="s1")
ok2 = input.bool(defval=true,title="",group = g_corr_pairs,inline="s2")
ok3 = input.bool(defval=true,title="",group = g_corr_pairs,inline="s3")
ok4 = input.bool(defval=true,title="",group = g_corr_pairs,inline="s4")

s1=input.symbol(defval = "PEPPERSTONE:NAS100",  title = "1 : " , group = g_corr_pairs,inline="s1")
s2=input.symbol(defval = "PEPPERSTONE:US500",   title = " & "  , group = g_corr_pairs,inline="s1")
s3=input.symbol(defval = "PEPPERSTONE:EURUSD",  title = "2 : " , group = g_corr_pairs,inline="s2")
s4=input.symbol(defval = "PEPPERSTONE:GBPUSD",   title = " & " , group = g_corr_pairs,inline="s2")
s5=input.symbol(defval = "PEPPERSTONE:XAUUSD",   title = "3 : " , group = g_corr_pairs,inline="s3")
s6=input.symbol(defval = "PEPPERSTONE:XAGUSD",   title = " & " , group = g_corr_pairs,inline="s3")
s7=input.symbol(defval = "BINANCE:BTCUSDT.P",   title = "4 : " , group = g_corr_pairs,inline="s4")
s8=input.symbol(defval = "BINANCE:ETHUSDT.P",   title = " & " , group = g_corr_pairs,inline="s4")

smt_clr     = input.color(color.new(color.purple,0), title  = "SMT",inline="clr2",group="SMT Colors") 
swp_clr     = input.color(color.new(color.blue,0), title  = "Sweep",inline="clr2",group="SMT Colors") 

//Table Location & Size
i_font     = input.string("tiny", "Text size",  options = ["tiny", "small",  "normal", "large", "huge"], group = "SMT Table")
i_pos      = input.string(position.middle_right, "Table Position", inline  = "1", options = [position.middle_right, position.top_right,position.bottom_right,position.bottom_center,position.bottom_left], group = "SMT Table")
i_main_clr = color.blue
i_title_clr = color.red
i_bgcolor  = color.teal
i_textcolor= color.white

// Trade Setup Settings
g_trade = "Trade Setup"
show_trade_levels = input.bool(true, "Show Entry/SL/TP Levels", group=g_trade)
auto_trade_detection = input.bool(true, "Auto Detect Trade Setups", group=g_trade)
entry_color = input.color(color.yellow, "Entry Line Color", group=g_trade)
sl_color = input.color(color.red, "Stop Loss Color", group=g_trade)
tp_color = input.color(color.green, "Take Profit Color", group=g_trade)
risk_reward_ratio = input.float(2.0, "Risk:Reward Ratio", minval=1.0, maxval=5.0, step=0.5, group=g_trade)
show_trade_labels = input.bool(true, "Show Trade Labels", group=g_trade)

sym = syminfo.tickerid 
tf_current = timeframe.period // Renamed to avoid conflict with local 'tf' in functions
var tablo2 = table.new(position = i_pos,columns = 10,rows = 20,frame_color=i_textcolor,frame_width=2,border_color=i_textcolor,border_width=1)
assets = array.from(str.contains(sym,s1),str.contains(sym,s2),str.contains(sym,s3),str.contains(sym,s4),str.contains(sym,s5),str.contains(sym,s6),str.contains(sym,s7),str.contains(sym,s8))
asset_ok = array.some(assets)

// Trade Setup Variables - Arrays to store last 3 setups
var array<line> entry_lines = array.new<line>()
var array<line> sl_lines = array.new<line>()
var array<line> tp1_lines = array.new<line>()
var array<line> tp2_lines = array.new<line>()
var array<line> tp3_lines = array.new<line>()
var array<label> entry_labels = array.new<label>()
var array<label> sl_labels = array.new<label>()
var array<label> tp_labels = array.new<label>()
var bool trade_active = false
var string current_trade_direction = ""
var float current_entry = na
var float current_sl = na

// Global CISD and signal variables for debug access
var bool cisd_bullish = false
var bool cisd_bearish = false
var string signal_dir = ""
var float signal_str = 0.0

// Global SMT variables for score table access
var bool tf1_bull_smt = false
var bool tf1_bear_smt = false
var bool tf2_bull_smt = false
var bool tf2_bear_smt = false
var bool tf4_bull_smt = false
var bool tf4_bear_smt = false
var bool tf5_bull_smt = false
var bool tf5_bear_smt = false

// Global sweep variables for score table access
var bool tf1_xl_sweep = false
var bool tf1_cl_sweep = false
var bool tf1_xh_sweep = false
var bool tf1_ch_sweep = false
var bool tf2_xl_sweep = false
var bool tf2_cl_sweep = false
var bool tf2_xh_sweep = false
var bool tf2_ch_sweep = false
var bool tf4_xl_sweep = false
var bool tf4_cl_sweep = false
var bool tf4_xh_sweep = false
var bool tf4_ch_sweep = false
var bool tf5_xl_sweep = false
var bool tf5_cl_sweep = false
var bool tf5_xh_sweep = false
var bool tf5_ch_sweep = false

// Global CRT variables for score table access
var float current_crt_high = na
var float current_crt_low = na

// Global timeframe variable
var int current_tf_seconds = na

// HTF Candle Data Structures (exact copy from fractal_model_indicator.pine)
type Candle
    float           o
    float           c
    float           h
    float           l
    int             o_idx
    int             c_idx
    int             h_idx
    int             l_idx
    box             body
    line            wick_up
    line            wick_down



type CandleSettings
    bool            show
    string          htf
    int             max_display
    color           bull_body
    color           bull_border
    color           bull_wick
    color           bear_body
    color           bear_border
    color           bear_wick
    int             offset
    int             buffer
    int             htf_buffer
    int             width
    bool            htf_label_show
    color           htf_label_color
    string          htf_label_size
    bool            htf_timer_show
    color           htf_timer_color
    string          htf_timer_size

type HTFImbalance
    box             b
    int             idx

type CandleSet
    CandleSettings  settings
    array<Candle>   candles
    array<HTFImbalance> imbalances
    array<line>     htf_starts

// HTF Candle Sets (exact copy)
var CandleSettings HTFSettings = CandleSettings.new()
var array<Candle> htf_candles_array = array.new<Candle>(0)
var array<HTFImbalance> htf_imbalances = array.new<HTFImbalance>()

var CandleSet htf1 = CandleSet.new()
htf1.settings := HTFSettings
htf1.candles := htf_candles_array
htf1.imbalances := htf_imbalances
htf1.htf_starts := array.new<line>()
var float current_tp1 = na
var float current_tp2 = na
var float current_tp3 = na

// Helper function to add to array and manage size (from all in one.txt)
add_to_array(arr, value) =>
    array.unshift(arr, value)
    if array.size(arr) > 100
        array.pop(arr)

// Function to manage trade line arrays (keep only last 3 setups)
manageTradeHistory() =>
    // Clean up if we have more than 3 setups
    while array.size(entry_lines) > 3
        old_entry = array.shift(entry_lines)
        if not na(old_entry)
            line.delete(old_entry)
    
    while array.size(sl_lines) > 3
        old_sl = array.shift(sl_lines)
        if not na(old_sl)
            line.delete(old_sl)
    
    while array.size(tp1_lines) > 3
        old_tp1 = array.shift(tp1_lines)
        if not na(old_tp1)
            line.delete(old_tp1)
    
    while array.size(tp2_lines) > 3
        old_tp2 = array.shift(tp2_lines)
        if not na(old_tp2)
            line.delete(old_tp2)
    
    while array.size(tp3_lines) > 3
        old_tp3 = array.shift(tp3_lines)
        if not na(old_tp3)
            line.delete(old_tp3)
    
    while array.size(entry_labels) > 3
        old_entry_label = array.shift(entry_labels)
        if not na(old_entry_label)
            label.delete(old_entry_label)
    
    while array.size(sl_labels) > 3
        old_sl_label = array.shift(sl_labels)
        if not na(old_sl_label)
            label.delete(old_sl_label)
    
    while array.size(tp_labels) > 3
        old_tp_label = array.shift(tp_labels)
        if not na(old_tp_label)
            label.delete(old_tp_label)

// Function to detect high-probability trade setups
detectTradeSetup(smt_bull, smt_bear, sweep_bull, sweep_bear, crt_high, crt_low, cisd_bull, cisd_bear) =>
    var string signal_direction = ""
    var float signal_strength = 0.0
    
    // Calculate signal strength based on confirmations
    bull_strength = 0.0
    bear_strength = 0.0
    
    // SMT confirmation (configurable weight)
    if smt_bull
        bull_strength += smt_points
    if smt_bear
        bear_strength += smt_points
    
    // Sweep confirmation (configurable weight)
    if sweep_bull == "✓ ✓"
        bull_strength += double_sweep_points
    else if sweep_bull == "✓ 𐄂" or sweep_bull == "𐄂 ✓"
        bull_strength += single_sweep_points
    
    if sweep_bear == "✓ ✓"
        bear_strength += double_sweep_points
    else if sweep_bear == "✓ 𐄂" or sweep_bear == "𐄂 ✓"
        bear_strength += single_sweep_points
    
    // CISD confirmation (configurable weight)
    if cisd_bull
        bull_strength += cisd_points
    if cisd_bear
        bear_strength += cisd_points
    
    // CRT level interaction (higher weight for range boundaries)
    if not na(crt_low) and not na(crt_high)
        crt_range = crt_high - crt_low
        crt_lower_zone = crt_low + (crt_range * 0.2)  // Lower 20% of range
        crt_upper_zone = crt_high - (crt_range * 0.2) // Upper 20% of range
        
        // Bullish: Price in lower zone or touching CRT low
        if (low <= crt_low and close > crt_low) or (close <= crt_lower_zone)
            bull_strength += crt_touch_points
        
        // Bearish: Price in upper zone or touching CRT high  
        if (high >= crt_high and close < crt_high) or (close >= crt_upper_zone)
            bear_strength += crt_touch_points
    
    // Determine signal direction (configurable minimum strength)
    if bull_strength >= min_entry_score and bull_strength > bear_strength
        signal_direction := "LONG"
        signal_strength := bull_strength
    else if bear_strength >= min_entry_score and bear_strength > bull_strength
        signal_direction := "SHORT"
        signal_strength := bear_strength
    else
        signal_direction := ""
        signal_strength := 0.0
    
    [signal_direction, signal_strength]

// Function to calculate trade levels within CRT range
calculateTradeLevels(direction, current_price, crt_high, crt_low, atr_value) =>
    var float entry = na
    var float stop_loss = na
    var float tp1 = na
    var float tp2 = na
    var float tp3 = na
    
    // Ensure we have valid CRT levels
    if not na(crt_high) and not na(crt_low)
        crt_range = crt_high - crt_low
        crt_mid = (crt_high + crt_low) / 2
        
        if direction == "LONG"
            // Long setup - Entry near CRT low, targets toward CRT high
            entry := crt_low + (crt_range * 0.1)        // Entry 10% above CRT low
            stop_loss := crt_low - (atr_value * 0.3)    // Stop below CRT low
            
            // Targets within and beyond CRT range
            tp1 := crt_mid                              // First target at CRT midpoint
            tp2 := crt_high - (crt_range * 0.1)        // Second target near CRT high
            tp3 := crt_high + (crt_range * 0.5)        // Extended target above CRT high
            
        else if direction == "SHORT"
            // Short setup - Entry near CRT high, targets toward CRT low
            entry := crt_high - (crt_range * 0.1)       // Entry 10% below CRT high
            stop_loss := crt_high + (atr_value * 0.3)   // Stop above CRT high
            
            // Targets within and beyond CRT range
            tp1 := crt_mid                              // First target at CRT midpoint
            tp2 := crt_low + (crt_range * 0.1)         // Second target near CRT low
            tp3 := crt_low - (crt_range * 0.5)         // Extended target below CRT low
    else
        // Fallback if no CRT levels available
        if direction == "LONG"
            entry := current_price + (atr_value * 0.1)
            stop_loss := current_price - (atr_value * 0.8)
            risk = entry - stop_loss
            tp1 := entry + (risk * 0.5)
            tp2 := entry + risk
            tp3 := entry + (risk * 1.5)
        else if direction == "SHORT"
            entry := current_price - (atr_value * 0.1)
            stop_loss := current_price + (atr_value * 0.8)
            risk = stop_loss - entry
            tp1 := entry - (risk * 0.5)
            tp2 := entry - risk
            tp3 := entry - (risk * 1.5)
    
    [entry, stop_loss, tp1, tp2, tp3]

// Function to create and store trade level lines in arrays
createTradeLevels(direction, entry, sl, tp1, tp2, tp3, strength) =>
    if show_trade_levels
        // Manage history first (keep only last 3)
        manageTradeHistory()
        
        // Update transparency for existing lines (make older ones more transparent)
        for i = 0 to array.size(entry_lines) - 1
            transparency_level = i == 0 ? 20 : (i == 1 ? 50 : 75)
            
            // Update entry lines
            if i < array.size(entry_lines)
                existing_entry = array.get(entry_lines, i)
                if not na(existing_entry)
                    line.set_color(existing_entry, color.new(color.yellow, transparency_level))
            
            // Update stop loss lines
            if i < array.size(sl_lines)
                existing_sl = array.get(sl_lines, i)
                if not na(existing_sl)
                    line.set_color(existing_sl, color.new(color.red, transparency_level))
            
            // Update target lines
            if i < array.size(tp1_lines)
                existing_tp1 = array.get(tp1_lines, i)
                if not na(existing_tp1)
                    line.set_color(existing_tp1, color.new(color.green, transparency_level))
            
            if i < array.size(tp2_lines)
                existing_tp2 = array.get(tp2_lines, i)
                if not na(existing_tp2)
                    line.set_color(existing_tp2, color.new(color.green, transparency_level))
            
            if i < array.size(tp3_lines)
                existing_tp3 = array.get(tp3_lines, i)
                if not na(existing_tp3)
                    line.set_color(existing_tp3, color.new(color.green, transparency_level))
        
        // Create new entry line (most recent, fully opaque)
        new_entry_line = line.new(bar_index, entry, bar_index + 20, entry, 
                                 color=entry_color, style=line.style_solid, width=2)
        array.push(entry_lines, new_entry_line)
        
        // Create new stop loss line
        new_sl_line = line.new(bar_index, sl, bar_index + 20, sl, 
                              color=sl_color, style=line.style_dashed, width=2)
        array.push(sl_lines, new_sl_line)
        
        // Create new target lines
        new_tp1_line = line.new(bar_index, tp1, bar_index + 20, tp1, 
                               color=tp_color, style=line.style_dotted, width=1)
        array.push(tp1_lines, new_tp1_line)
        
        new_tp2_line = line.new(bar_index, tp2, bar_index + 20, tp2, 
                               color=tp_color, style=line.style_dotted, width=2)
        array.push(tp2_lines, new_tp2_line)
        
        new_tp3_line = line.new(bar_index, tp3, bar_index + 20, tp3, 
                               color=tp_color, style=line.style_dotted, width=1)
        array.push(tp3_lines, new_tp3_line)
        
        // Create labels if enabled
        if show_trade_labels
            entry_text = direction + " ENTRY\n" + str.tostring(entry, "#.##") + "\nStrength: " + str.tostring(strength, "#.#")
            new_entry_label = label.new(bar_index + 22, entry, entry_text, 
                                       color=entry_color, textcolor=color.white, 
                                       style=label.style_label_left, size=size.small)
            array.push(entry_labels, new_entry_label)
            
            sl_text = "STOP LOSS\n" + str.tostring(sl, "#.##")
            new_sl_label = label.new(bar_index + 22, sl, sl_text, 
                                    color=sl_color, textcolor=color.white, 
                                    style=label.style_label_left, size=size.small)
            array.push(sl_labels, new_sl_label)
            
            tp_text = "TARGETS\nTP1: " + str.tostring(tp1, "#.##") + "\nTP2: " + str.tostring(tp2, "#.##") + "\nTP3: " + str.tostring(tp3, "#.##")
            new_tp_label = label.new(bar_index + 22, tp2, tp_text, 
                                    color=tp_color, textcolor=color.white, 
                                    style=label.style_label_left, size=size.small)
            array.push(tp_labels, new_tp_label)

// Function to get live symbol data (from all in one.txt)
f_live_sym(_xc0,_xo0,_xh0,_xl0,_xt0,xtf)=>
    var _c1 = 0.0, var _o1 = 0.0 , var _h1 = 0.0, var _l1 = 0.0, var _t1 = 0
    var _c2 = 0.0, var _o2 = 0.0 , var _h2 = 0.0, var _l2 = 0.0, var _t2 = 0    
    var _o0 = 0.0
    var _h0 = 0.0
    var _l0 = 0.0
    var _t0 = 0
    var _c0 = 0.0
    if timeframe.change(xtf)
        _t0 := _xt0
        _o0 := _xo0
        _h0 := _xh0
        _l0 := _xl0
        
    if _xh0 >= _h0
        _h0 := _xh0
    if _xl0 <= _l0
        _l0 := _xl0
    _c0 := _xc0
    if timeframe.change(xtf)
        _c1  :=  _c0[1]
        _o1  :=  _o0[1]
        _h1  :=  _h0[1]
        _l1  :=  _l0[1]
        _t1  :=  _t0[1]
        _c2  :=  _c1[1]
        _o2  :=  _o1[1]
        _h2  :=  _h1[1]
        _l2  :=  _l1[1]
        _t2  :=  _t1[1]        
    [_h2,_l2,_c2,_o2,_t2,_h1,_l1,_c1,_o1,_t1,_h0,_l0,_c0,_o0,_t0] 

// Function to format timeframe text (from all in one.txt)
f_text(string _tf)=>
    _text = str.tonumber(_tf) < 59 ? _tf + 'm'  :
     str.tonumber(_tf) > 59  ? 'h'+ str.tostring(math.floor(str.tonumber(_tf)/60))    : _tf
    _text := _tf == "1D" ? "D" : _tf == "1W" ? "W" : _tf == "1M" ? "M" : _text

// Function to check if timeframe is valid (from all in one.txt)
tf_ok(_htf) =>
    _ok  = timeframe.in_seconds(_htf) >= timeframe.in_seconds(tf_current)
    _ok := _htf == "360" and (tf_current == "240" or tf_current=="300") ? false : _ok  

// Function to get mini time data (from all in one.txt)
f_live_mini_time(_htf)=>
    var _h0 = high
    var _l0 = low
    var _h0t = time
    var _l0t = time
    var _h1t = time
    var _l1t = time
    var _h2t = time
    var _l2t = time
    if timeframe.change(_htf)
        _h0 := high
        _l0 := low
    if high >= _h0
        _h0   := high
        _h0t  := time
        
    if low <= _l0
        _l0   := low
        _l0t  := time
        
    if timeframe.change(_htf)        
        _h1t  := _h0t[1]
        _l1t  := _l0t[1]
        _h2t  := _h1t[1]
        _l2t  := _l1t[1]

    [_h2t,_l2t,_h1t,_l1t,_h0t,_l0t]

// SMT calculation function (from all in one.txt)
f_smt(_tf,_tfok)=>
    csym   = sym
    csym  := str.contains(sym,s1) and ok1 ? s2 : str.contains(sym,s2)and ok2 ? s1 : csym
    csym  := str.contains(sym,s3) and ok2 ? s4 : str.contains(sym,s4)and ok2 ? s3 : csym
    csym  := str.contains(sym,s5) and ok3 ? s6 : str.contains(sym,s6)and ok3 ? s5 : csym
    csym  := str.contains(sym,s7) and ok4 ? s8 : str.contains(sym,s8)and ok4 ? s7 : csym        
    par_ok = csym != sym
    [cc,co,ch,cl,ct]=request.security(csym,tf_current,[close,open,high,low,time],lookahead = barmerge.lookahead_on,gaps = barmerge.gaps_on, ignore_invalid_symbol = true)
    
    [xh2,xl2,xc2,xo2,xt2,xh1,xl1,xc1,xo1,xt1,xh0,xl0,xc0,xo0,xt0] = f_live_sym(close,open,high,low,time,_tf) 
    [ch2,cl2,cc2,co2,ct2,ch1,cl1,cc1,co1,ct1,ch0,cl0,cc0,co0,ct0] = f_live_sym(cc,co,ch,cl,ct,_tf)


    bear_smt1 = ((xh0 > xh1 and ch0 <= ch1 ) or (xh0 <= xh1 and ch0 > ch1)) and par_ok and tf_ok(_tf)
    bull_smt1 = ((xl0 < xl1 and cl0 >= cl1 ) or (xl0 >= xl1 and cl0 < cl1)) and par_ok and tf_ok(_tf)
    bear_smt2 = ((xh1 < xh2 and xh0 > xh2 and ch1 < ch0 and ch2 > ch0) or ( xh1 < xh0 and xh2 > xh0 and ch1 < ch2 and ch0 > ch2)) and par_ok and tf_ok(_tf)
    bull_smt2 = ((xl1 > xl2 and xl0 < xl2 and cl1 > cl0 and cl2 < cl0) or ( xl1 > xl0 and xl2 < xl0 and cl1 > cl2 and cl0 < cl2)) and par_ok and tf_ok(_tf)
    bull_smt  = bull_smt1 or bull_smt2
    bear_smt  = bear_smt1 or bear_smt2
    bull_num   = bull_smt2 ? 2 : bull_smt1 ? 1 : 0
    bear_num   = bear_smt2 ? 2 : bear_smt1 ? 1 : 0
    xh_sweep = xh0 > xh1 and xc0 < xh1 and tf_ok(_tf)
    xl_sweep = xl0 < xl1 and xc0 > xl1 and tf_ok(_tf)
    ch_sweep = ch0 > ch1 and cc0 < ch1 and tf_ok(_tf)
    cl_sweep = cl0 < cl1 and cc0 > cl1 and tf_ok(_tf)
    
    if par_ok and show_smt_table and show_swe_table
        table.merge_cells(tablo2,0,10,6,10)
        table.cell(tablo2,0,10,text= "Corele asset : " + str.tostring(csym),text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
    if par_ok and show_smt_table and not show_swe_table
        table.merge_cells(tablo2,0,10,2,10)
        table.cell(tablo2,0,10,text= "Corele : " + str.tostring(csym),text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
    var bullalerttrigger1 = false
    var bearalerttrigger1 = false
    var bullalerttrigger2 = false
    var bearalerttrigger2 = false

    if timeframe.change(_tf)
        bullalerttrigger1 := false
        bearalerttrigger1 := false
        bullalerttrigger2 := false
        bearalerttrigger2 := false

    bullalert = par_ok and _tfok and bull_smt and (xl_sweep or cl_sweep) and alert1_on and bualert
    bearalert = par_ok and _tfok and bear_smt and (xh_sweep or ch_sweep) and alert1_on and bealert

    if bullalert and bullalerttrigger1== false
        alert(str.tostring(syminfo.ticker(sym))+" " + f_text(_tf) + " Bullish Alert SMT + Sweep", alert.freq_once_per_bar)
        bullalerttrigger1 := true
    if bearalert and bearalerttrigger1== false
        alert(str.tostring(syminfo.ticker(sym))+" " + f_text(_tf) + " Bearish Alert SMT + Sweep", alert.freq_once_per_bar)
        bearalerttrigger1 := true

    bullalert2 = par_ok and _tfok and xl_sweep and cl_sweep and alert2_on and bualert
    bearalert2 = par_ok and _tfok and xh_sweep and ch_sweep and alert2_on and bealert

    if bullalert2 and bullalerttrigger2== false
        alert(str.tostring(syminfo.ticker(sym))+" " + f_text(_tf) + " Bullish Alert Sweep + Sweep", alert.freq_once_per_bar)
        bullalerttrigger2 := true
    if bearalert2 and bearalerttrigger2== false
        alert(str.tostring(syminfo.ticker(sym))+" " + f_text(_tf) + " Bearish Alert Sweep + Sweep", alert.freq_once_per_bar)
        bearalerttrigger2 := true
    var smtbeh = line.new(na,na,na,na)
    var smtbul = line.new(na,na,na,na)
    var swebeh = line.new(na,na,na,na)
    var swebul = line.new(na,na,na,na)        
    line.delete(smtbeh)
    line.delete(smtbul)
    line.delete(swebeh)
    line.delete(swebul)    
    [h2t,l2t,h1t,l1t,h0t,l0t] = f_live_mini_time(_tf)
    if par_ok and tf_ok(_tf) and smt_on_chart and (bull_smt or bear_smt) and tf_current == _tf and _tfok // added 3108
        if bear_smt and not (bear_num == 0)

            x1 = bear_num == 1 ? h1t : bear_num == 2 ? h2t : 0
            y1 = bear_num == 1 ? xh1 : bear_num == 2 ? xh2 : 0
            smtbeh := line.new(x1 = x1 , y1 = y1 , x2 = h0t , y2 = xh0 , xloc=xloc.bar_time,color= smt_clr,width = 2,style=style_smt) 
        if bull_smt and not (bull_num == 0)

            x1 = bull_num == 1 ? l1t : bull_num == 2 ? l2t : 0
            y1 = bull_num == 1 ? xl1 : bull_num == 2 ? xl2 : 0
            smtbul := line.new(x1 = x1 , y1 = y1 , x2 = l0t , y2 = xl0 , xloc=xloc.bar_time,color= smt_clr,width = 2,style = style_smt)

    if tf_ok(_tf) and sweep_on_chart and (xh_sweep or xl_sweep) and tf_current == _tf and _tfok // added 3108
        if xh_sweep
            swebeh := line.new(x1 = h1t , y1 = xh1 , x2 = h0t , y2 = xh1 , xloc=xloc.bar_time,color= swp_clr,width = 2,style =  style_swp) 
        if xl_sweep 
            swebul := line.new(x1 = l1t , y1 = xl1 , x2 = l0t , y2 = xl1 , xloc=xloc.bar_time,color= swp_clr,width = 2,style = style_swp)             

    [bull_smt,bear_smt,bull_num,bear_num,xh_sweep,xl_sweep,ch_sweep,cl_sweep]

// SMT text formatting functions (from all in one.txt)
f_smt_txt(bool _alarm) =>
    _textt = _alarm ? "✓": "𐄂"
f_swp_txt(bool _alarm1, bool _alarm2) =>
    _textt1 =_alarm1 and _alarm2 ? "✓ ✓" :_alarm1 and not _alarm2 ? "✓ 𐄂": not _alarm1 and _alarm2 ?"𐄂 ✓" : "𐄂 𐄂"
    _textt  = asset_ok ? _textt1 : _alarm1 ? " ✓ " : " 𐄂 "
    _textt

// SMT Execution
if timeframe.in_seconds(tf_current) >= timeframe.in_seconds("1")
    [temp_tf1_bull_smt,temp_tf1_bear_smt,tf1_bull_num,tf1_bear_num,temp_tf1_xh_sweep,temp_tf1_xl_sweep,temp_tf1_ch_sweep,temp_tf1_cl_sweep] = f_smt(smt_tf1,smt_tfok1)
    tf1_bull_smt := temp_tf1_bull_smt
    tf1_bear_smt := temp_tf1_bear_smt
    tf1_xh_sweep := temp_tf1_xh_sweep
    tf1_xl_sweep := temp_tf1_xl_sweep
    tf1_ch_sweep := temp_tf1_ch_sweep
    tf1_cl_sweep := temp_tf1_cl_sweep
    [temp_tf2_bull_smt,temp_tf2_bear_smt,tf2_bull_num,tf2_bear_num,temp_tf2_xh_sweep,temp_tf2_xl_sweep,temp_tf2_ch_sweep,temp_tf2_cl_sweep] = f_smt(smt_tf2,smt_tfok2)
    tf2_bull_smt := temp_tf2_bull_smt
    tf2_bear_smt := temp_tf2_bear_smt
    tf2_xh_sweep := temp_tf2_xh_sweep
    tf2_xl_sweep := temp_tf2_xl_sweep
    tf2_ch_sweep := temp_tf2_ch_sweep
    tf2_cl_sweep := temp_tf2_cl_sweep 
    [tf3_bull_smt,tf3_bear_smt,tf3_bull_num,tf3_bear_num,tf3_xh_sweep,tf3_xl_sweep,tf3_ch_sweep,tf3_cl_sweep] = f_smt(smt_tf3,smt_tfok3) 
    [temp_tf4_bull_smt,temp_tf4_bear_smt,tf4_bull_num,tf4_bear_num,temp_tf4_xh_sweep,temp_tf4_xl_sweep,temp_tf4_ch_sweep,temp_tf4_cl_sweep] = f_smt(smt_tf4,smt_tfok4)
    tf4_bull_smt := temp_tf4_bull_smt
    tf4_bear_smt := temp_tf4_bear_smt
    tf4_xh_sweep := temp_tf4_xh_sweep
    tf4_xl_sweep := temp_tf4_xl_sweep
    tf4_ch_sweep := temp_tf4_ch_sweep
    tf4_cl_sweep := temp_tf4_cl_sweep
    [temp_tf5_bull_smt,temp_tf5_bear_smt,tf5_bull_num,tf5_bear_num,temp_tf5_xh_sweep,temp_tf5_xl_sweep,temp_tf5_ch_sweep,temp_tf5_cl_sweep] = f_smt(smt_tf5,smt_tfok5)
    tf5_bull_smt := temp_tf5_bull_smt
    tf5_bear_smt := temp_tf5_bear_smt
    tf5_xh_sweep := temp_tf5_xh_sweep
    tf5_xl_sweep := temp_tf5_xl_sweep
    tf5_ch_sweep := temp_tf5_ch_sweep
    tf5_cl_sweep := temp_tf5_cl_sweep
    [tf6_bull_smt,tf6_bear_smt,tf6_bull_num,tf6_bear_num,tf6_xh_sweep,tf6_xl_sweep,tf6_ch_sweep,tf6_cl_sweep] = f_smt(smt_tf6,smt_tfok6)
    [tf7_bull_smt,tf7_bear_smt,tf7_bull_num,tf7_bear_num,tf7_xh_sweep,tf7_xl_sweep,tf7_ch_sweep,tf7_cl_sweep] = f_smt(smt_tf7,smt_tfok7)
    [tf8_bull_smt,tf8_bear_smt,tf8_bull_num,tf8_bear_num,tf8_xh_sweep,tf8_xl_sweep,tf8_ch_sweep,tf8_cl_sweep] = f_smt(smt_tf8,smt_tfok8)
    [tf9_bull_smt,tf9_bear_smt,tf9_bull_num,tf9_bear_num,tf9_xh_sweep,tf9_xl_sweep,tf9_ch_sweep,tf9_cl_sweep] = f_smt(smt_tf9,smt_tfok9)

    if show_smt_table and asset_ok
        table.cell(tablo2,0,0,text="SMT" ,text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
        table.cell(tablo2,1,0,text="Bullish"  ,text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
        table.cell(tablo2,2,0,text="Bearish" ,text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
    if show_swe_table    
        table.cell(tablo2,3,0,text="SWP" ,text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
        table.cell(tablo2,4,0,text="Bullish"  ,text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
        table.cell(tablo2,5,0,text="Bearish" ,text_color=i_textcolor,bgcolor= i_main_clr, text_size = i_font)
    if smt_tfok1 and tf_ok(smt_tf1)
        if show_smt_table and asset_ok       
            table.cell(tablo2,0,1,text=f_text(smt_tf1) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,1,text=f_smt_txt(tf1_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,1,text=f_smt_txt(tf1_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,1,text=f_text(smt_tf1) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,1,text=f_swp_txt(tf1_xl_sweep, tf1_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,1,text=f_swp_txt(tf1_xh_sweep, tf1_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
    if smt_tfok2 and tf_ok(smt_tf2)
        if show_smt_table and asset_ok
            table.cell(tablo2,0,2,text=f_text(smt_tf2) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,2,text=f_smt_txt(tf2_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,2,text=f_smt_txt(tf2_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,2,text=f_text(smt_tf2) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,2,text=f_swp_txt(tf2_xl_sweep, tf2_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,2,text=f_swp_txt(tf2_xh_sweep, tf2_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal) 
    if smt_tfok3 and tf_ok(smt_tf3)
        if show_smt_table  and asset_ok      
            table.cell(tablo2,0,3,text=f_text(smt_tf3) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,3,text=f_smt_txt(tf3_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,3,text=f_smt_txt(tf3_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,3,text=f_text(smt_tf3) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,3,text=f_swp_txt(tf3_xl_sweep, tf3_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,3,text=f_swp_txt(tf3_xh_sweep, tf3_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
    if smt_tfok4 and tf_ok(smt_tf4)
        if show_smt_table and asset_ok
            table.cell(tablo2,0,4,text=f_text(smt_tf4) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,4,text=f_smt_txt(tf4_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,4,text=f_smt_txt(tf4_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,4,text=f_text(smt_tf4) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,4,text=f_swp_txt(tf4_xl_sweep, tf4_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,4,text=f_swp_txt(tf4_xh_sweep, tf4_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
    if smt_tfok5 and tf_ok(smt_tf5)
        if show_smt_table and asset_ok
            table.cell(tablo2,0,5,text=f_text(smt_tf5) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,5,text=f_smt_txt(tf5_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,5,text=f_smt_txt(tf5_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,5,text=f_text(smt_tf5) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,5,text=f_swp_txt(tf5_xl_sweep, tf5_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,5,text=f_swp_txt(tf5_xh_sweep, tf5_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)            
    if smt_tfok6 and tf_ok(smt_tf6)
        if show_smt_table and asset_ok
            table.cell(tablo2,0,6,text=f_text(smt_tf6) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,6,text=f_smt_txt(tf6_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,6,text=f_smt_txt(tf6_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,6,text=f_text(smt_tf6) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,6,text=f_swp_txt(tf6_xl_sweep, tf6_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,6,text=f_swp_txt(tf6_xh_sweep, tf6_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
    if smt_tfok7 and tf_ok(smt_tf7)
        if show_smt_table and asset_ok
            table.cell(tablo2,0,7,text=f_text(smt_tf7) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,7,text=f_smt_txt(tf7_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,7,text=f_smt_txt(tf7_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,7,text=f_text(smt_tf7) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,7,text=f_swp_txt(tf7_xl_sweep, tf7_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,7,text=f_swp_txt(tf7_xh_sweep, tf7_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
    if smt_tfok8 and tf_ok(smt_tf8)
        if show_smt_table and asset_ok
            table.cell(tablo2,0,8,text=f_text(smt_tf8) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,8,text=f_smt_txt(tf8_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,8,text=f_smt_txt(tf8_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,8,text=f_text(smt_tf8) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,8,text=f_swp_txt(tf8_xl_sweep, tf8_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,8,text=f_swp_txt(tf8_xh_sweep, tf8_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)            
    if smt_tfok9 and tf_ok(smt_tf9)
        if show_smt_table and asset_ok
            table.cell(tablo2,0,9,text=f_text(smt_tf9) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,1,9,text=f_smt_txt(tf9_bull_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,2,9,text=f_smt_txt(tf9_bear_smt) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
        if show_swe_table        
            table.cell(tablo2,3,9,text=f_text(smt_tf9) ,text_color=i_textcolor,bgcolor= i_title_clr, text_size = i_font)
            table.cell(tablo2,4,9,text=f_swp_txt(tf9_xl_sweep, tf9_cl_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)
            table.cell(tablo2,5,9,text=f_swp_txt(tf9_xh_sweep, tf9_ch_sweep) ,text_color=i_textcolor,bgcolor= i_bgcolor, text_size = size.normal)

    // Trade Setup Detection and Plotting
    if auto_trade_detection and show_trade_levels
        // Get ATR for dynamic level calculation
        atr_value = ta.atr(14)
    
        // Get appropriate CRT levels based on current chart timeframe
        current_tf_seconds := timeframe.in_seconds()
        
        // Determine which HTF to use based on current timeframe
        current_crt_high := if current_tf_seconds <= timeframe.in_seconds("15")
            // For 1m-15m charts, use 1H CRT
            if use_tf1 and tf_ok(tf1)  // tf1 = 1H (60 minutes)
                high1
            else if use_tf2 and tf_ok(tf2)  // tf2 = 4H as fallback
                high2
            else
                na
        else if current_tf_seconds <= timeframe.in_seconds("60")
            // For 30m-1H charts, use 4H CRT
            if use_tf2 and tf_ok(tf2)  // tf2 = 4H (240 minutes)
                high2
            else if use_tf4 and tf_ok(tf4)  // tf4 = Daily as fallback
                high4
            else
                na
        else if current_tf_seconds <= timeframe.in_seconds("240")
            // For 2H-4H charts, use Daily CRT
            if use_tf4 and tf_ok(tf4)  // tf4 = Daily
                high4
            else if use_tf5 and tf_ok(tf5)  // tf5 = Weekly as fallback
                high5
            else
                na
        else
            // For Daily+ charts, use Weekly CRT
            if use_tf5 and tf_ok(tf5)  // tf5 = Weekly
                high5
            else if use_tf6 and tf_ok(tf6)  // tf6 = Monthly as fallback
                high6
            else
                na
        
        current_crt_low := if current_tf_seconds <= timeframe.in_seconds("15")
            // For 1m-15m charts, use 1H CRT
            if use_tf1 and tf_ok(tf1)  // tf1 = 1H (60 minutes)
                low1
            else if use_tf2 and tf_ok(tf2)  // tf2 = 4H as fallback
                low2
            else
                na
        else if current_tf_seconds <= timeframe.in_seconds("60")
            // For 30m-1H charts, use 4H CRT
            if use_tf2 and tf_ok(tf2)  // tf2 = 4H (240 minutes)
                low2
            else if use_tf4 and tf_ok(tf4)  // tf4 = Daily as fallback
                low4
            else
                na
        else if current_tf_seconds <= timeframe.in_seconds("240")
            // For 2H-4H charts, use Daily CRT
            if use_tf4 and tf_ok(tf4)  // tf4 = Daily
                low4
            else if use_tf5 and tf_ok(tf5)  // tf5 = Weekly as fallback
                low5
            else
                na
        else
            // For Daily+ charts, use Weekly CRT
            if use_tf5 and tf_ok(tf5)  // tf5 = Weekly
                low5
            else if use_tf6 and tf_ok(tf6)  // tf6 = Monthly as fallback
                low6
            else
                na
        
        // Enhanced CISD signals detection (directional bias after sweep confirmation)
        cisd_bullish := false
        cisd_bearish := false
        
        // Determine current sweep bias for directional filtering
        current_low_sweep = false
        current_high_sweep = false
        if current_tf_seconds <= timeframe.in_seconds("15")
            current_low_sweep := tf1_xl_sweep or tf1_cl_sweep
            current_high_sweep := tf1_xh_sweep or tf1_ch_sweep
        else if current_tf_seconds <= timeframe.in_seconds("60")
            current_low_sweep := tf2_xl_sweep or tf2_cl_sweep
            current_high_sweep := tf2_xh_sweep or tf2_ch_sweep
        else if current_tf_seconds <= timeframe.in_seconds("240")
            current_low_sweep := tf4_xl_sweep or tf4_cl_sweep
            current_high_sweep := tf4_xh_sweep or tf4_ch_sweep
        else
            current_low_sweep := tf5_xl_sweep or tf5_cl_sweep
            current_high_sweep := tf5_xh_sweep or tf5_ch_sweep
        
        // Bullish CISD: Only after low sweep (bullish bias)
        if array.size(cisdLevelsBu) > 0 and current_low_sweep and not current_high_sweep
            latest_bull_cisd = array.get(cisdLevelsBu, 0)
            cisd_level = latest_bull_cisd.level.get_y2()
            
            // Bullish CISD: Low sweep occurred + price breaking above CISD + momentum confirmation
            was_below_cisd = close[1] <= cisd_level or close[2] <= cisd_level
            cisd_bullish := close > cisd_level and was_below_cisd and close > open
        
        // Bearish CISD: Only after high sweep (bearish bias)
        if array.size(cisdLevelsBe) > 0 and current_high_sweep and not current_low_sweep
            latest_bear_cisd = array.get(cisdLevelsBe, 0)
            cisd_level = latest_bear_cisd.level.get_y2()
            
            // Bearish CISD: High sweep occurred + price breaking below CISD + momentum confirmation
            was_above_cisd = close[1] >= cisd_level or close[2] >= cisd_level
            cisd_bearish := close < cisd_level and was_above_cisd and close < open
        
        // Detect trade setup using timeframe-appropriate signals
        signal_dir := ""
        signal_str := 0.0
        
        if current_tf_seconds <= timeframe.in_seconds("15")
            // For 1m-15m charts, use 1H SMT signals (tf1 = 1H) with fallback
            if smt_tfok1 and tf_ok(smt_tf1)
                [temp_dir, temp_str] = detectTradeSetup(
                    tf1_bull_smt, tf1_bear_smt, 
                    f_swp_txt(tf1_xl_sweep, tf1_cl_sweep), f_swp_txt(tf1_xh_sweep, tf1_ch_sweep),
                    current_crt_high, current_crt_low, 
                    cisd_bullish, cisd_bearish)
                signal_dir := temp_dir
                signal_str := temp_str
            else if smt_tfok6 and tf_ok(smt_tf6)  // Fallback to TF6 (2H)
                [temp_dir, temp_str] = detectTradeSetup(
                    tf6_bull_smt, tf6_bear_smt, 
                    f_swp_txt(tf6_xl_sweep, tf6_cl_sweep), f_swp_txt(tf6_xh_sweep, tf6_ch_sweep),
                    current_crt_high, current_crt_low, 
                    cisd_bullish, cisd_bearish)
                signal_dir := temp_dir
                signal_str := temp_str
        else if current_tf_seconds <= timeframe.in_seconds("60")
            // For 30m-1H charts, use 4H SMT signals (tf2 = 4H) with fallback
            if smt_tfok2 and tf_ok(smt_tf2)
                [temp_dir, temp_str] = detectTradeSetup(
                    tf2_bull_smt, tf2_bear_smt, 
                    f_swp_txt(tf2_xl_sweep, tf2_cl_sweep), f_swp_txt(tf2_xh_sweep, tf2_ch_sweep),
                    current_crt_high, current_crt_low, 
                    cisd_bullish, cisd_bearish)
                signal_dir := temp_dir
                signal_str := temp_str
            else if smt_tfok7 and tf_ok(smt_tf7)  // Fallback to TF7 (6H)
                [temp_dir, temp_str] = detectTradeSetup(
                    tf7_bull_smt, tf7_bear_smt, 
                    f_swp_txt(tf7_xl_sweep, tf7_cl_sweep), f_swp_txt(tf7_xh_sweep, tf7_ch_sweep),
                    current_crt_high, current_crt_low, 
                    cisd_bullish, cisd_bearish)
                signal_dir := temp_dir
                signal_str := temp_str
        else if current_tf_seconds <= timeframe.in_seconds("240")
            // For 2H-4H charts, use Daily SMT signals (tf4)
            if smt_tfok4 and tf_ok(smt_tf4)
                [temp_dir, temp_str] = detectTradeSetup(
                    tf4_bull_smt, tf4_bear_smt, 
                    f_swp_txt(tf4_xl_sweep, tf4_cl_sweep), f_swp_txt(tf4_xh_sweep, tf4_ch_sweep),
                    current_crt_high, current_crt_low, 
                    cisd_bullish, cisd_bearish)
                signal_dir := temp_dir
                signal_str := temp_str
        else
            // For Daily+ charts, use Weekly SMT signals (tf5)
            if smt_tfok5 and tf_ok(smt_tf5)
                [temp_dir, temp_str] = detectTradeSetup(
                    tf5_bull_smt, tf5_bear_smt, 
                    f_swp_txt(tf5_xl_sweep, tf5_cl_sweep), f_swp_txt(tf5_xh_sweep, tf5_ch_sweep),
                    current_crt_high, current_crt_low, 
                    cisd_bullish, cisd_bearish)
                signal_dir := temp_dir
                signal_str := temp_str
            
            // Only create new trade if signal is strong and no current trade
            if signal_dir != "" and not trade_active
                [entry_level, sl_level, tp1_level, tp2_level, tp3_level] = calculateTradeLevels(
                    signal_dir, close, current_crt_high, current_crt_low, atr_value)
                
                // Create new trade levels (automatically manages history of last 3)
                createTradeLevels(signal_dir, entry_level, sl_level, tp1_level, tp2_level, tp3_level, signal_str)
                
                // Update trade state
                trade_active := true
                current_trade_direction := signal_dir
                current_entry := entry_level
                current_sl := sl_level
                current_tp1 := tp1_level
                current_tp2 := tp2_level
                current_tp3 := tp3_level
                
                // Send alert
                alert_msg = "🚨 " + signal_dir + " SETUP DETECTED 🚨\n" +
                           "Symbol: " + syminfo.ticker + "\n" +
                           "Entry: " + str.tostring(entry_level, "#.##") + "\n" +
                           "Stop: " + str.tostring(sl_level, "#.##") + "\n" +
                           "Target: " + str.tostring(tp2_level, "#.##") + "\n" +
                           "Strength: " + str.tostring(signal_str, "#.#")
                alert(alert_msg, alert.freq_once_per_bar)
    
        // Check if current trade should be closed
        if trade_active
            trade_hit = false
            
            if current_trade_direction == "LONG"
                // Check if stop loss or target hit
                if low <= current_sl or high >= current_tp1
                    trade_hit := true
            else if current_trade_direction == "SHORT"
                // Check if stop loss or target hit  
                if high >= current_sl or low <= current_tp1
                    trade_hit := true
            
            // Close trade if hit
            if trade_hit
                trade_active := false
                current_trade_direction := ""
                // Keep lines visible for reference, don't clear immediately
        
        // Extend all trade lines (keep them current)
        if array.size(entry_lines) > 0
            for i = 0 to array.size(entry_lines) - 1
                if i < array.size(entry_lines)
                    line_entry = array.get(entry_lines, i)
                    if not na(line_entry)
                        line.set_x2(line_entry, bar_index + 20)
                
                if i < array.size(sl_lines)
                    line_sl = array.get(sl_lines, i)
                    if not na(line_sl)
                        line.set_x2(line_sl, bar_index + 20)
                
                if i < array.size(tp1_lines)
                    line_tp1 = array.get(tp1_lines, i)
                    if not na(line_tp1)
                        line.set_x2(line_tp1, bar_index + 20)
                
                if i < array.size(tp2_lines)
                    line_tp2 = array.get(tp2_lines, i)
                    if not na(line_tp2)
                        line.set_x2(line_tp2, bar_index + 20)
                
                if i < array.size(tp3_lines)
                    line_tp3 = array.get(tp3_lines, i)
                    if not na(line_tp3)
                        line.set_x2(line_tp3, bar_index + 20)
            
            // Extend labels if enabled
            if show_trade_labels
                for i = 0 to array.size(entry_labels) - 1
                    if i < array.size(entry_labels)
                        label_entry = array.get(entry_labels, i)
                        if not na(label_entry)
                            label.set_x(label_entry, bar_index + 22)
                    
                    if i < array.size(sl_labels)
                        label_sl = array.get(sl_labels, i)
                        if not na(label_sl)
                            label.set_x(label_sl, bar_index + 22)
                    
                    if i < array.size(tp_labels)
                        label_tp = array.get(tp_labels, i)
                        if not na(label_tp)
                            label.set_x(label_tp, bar_index + 22)

// CISD visualization options
cisd_display_mode = input.string(defval="All CISD", title="CISD Display Mode", options=["All CISD", "Entry Only"], group="Entry Score Configuration", tooltip="Show all CISD signals or only those contributing to entries")

// CISD visualization based on selected mode
show_cisd_bullish = cisd_display_mode == "All CISD" ? cisd_bullish : (cisd_bullish and signal_str >= min_entry_score and signal_dir == "LONG")
show_cisd_bearish = cisd_display_mode == "All CISD" ? cisd_bearish : (cisd_bearish and signal_str >= min_entry_score and signal_dir == "SHORT")

plotshape(show_cisd_bullish, title="CISD Bullish", location=location.belowbar, 
          color=color.green, style=shape.triangleup, size=size.small, text="CISD↑")
plotshape(show_cisd_bearish, title="CISD Bearish", location=location.abovebar, 
          color=color.red, style=shape.triangledown, size=size.small, text="CISD↓")

// Auto HTF Detection Logic (Pine Script compatible format)
htf_timeframe = htf_mode == "Auto" ? 
               (timeframe.in_seconds() <= 300 ? "60" :      // 5m and below -> 1H (60 minutes)
                timeframe.in_seconds() <= 3600 ? "240" :    // 1H and below -> 4H (240 minutes)  
                timeframe.in_seconds() <= 14400 ? "1D" :    // 4H and below -> 1D
                timeframe.in_seconds() <= 86400 ? "1W" :    // 1D and below -> 1W
                "1M") : custom_htf                          // Above 1D -> 1M or custom

// Get HTF data (global scope for timer access)
[htf_o, htf_h, htf_l, htf_c, htf_time] = request.security(syminfo.tickerid, htf_timeframe, [open, high, low, close, time], lookahead=barmerge.lookahead_off)

// HTF Candles Implementation (simplified but complete)
if show_htf_candles
    
    // HTF candle change detection
    var int last_htf_time = na
    var bool new_htf_candle = false
    
    if na(last_htf_time) or htf_time != last_htf_time
        last_htf_time := htf_time
        new_htf_candle := true
        
        // Clean up old candles
        while array.size(htf_candles_array) >= htf_max_display
            old_candle = array.shift(htf_candles_array)
            if not na(old_candle.body)
                box.delete(old_candle.body)
            if not na(old_candle.wick_up)
                line.delete(old_candle.wick_up)
            if not na(old_candle.wick_down)
                line.delete(old_candle.wick_down)
        
        // Create new candle
        new_candle = Candle.new()
        new_candle.o := htf_o
        new_candle.h := htf_h
        new_candle.l := htf_l
        new_candle.c := htf_c
        new_candle.o_idx := bar_index
        new_candle.c_idx := bar_index
        new_candle.h_idx := bar_index
        new_candle.l_idx := bar_index
        
        array.push(htf_candles_array, new_candle)
    else
        // Update current candle
        if array.size(htf_candles_array) > 0
            current_candle = array.get(htf_candles_array, array.size(htf_candles_array) - 1)
            current_candle.h := math.max(current_candle.h, htf_h)
            current_candle.l := math.min(current_candle.l, htf_l)
            current_candle.c := htf_c
    
    // Draw candles
    if array.size(htf_candles_array) > 0
        for i = 0 to array.size(htf_candles_array) - 1
            candle = array.get(htf_candles_array, i)
            
            // Position calculation (exact from original)
            x_left = bar_index + htf_offset + (i * (htf_width + htf_buffer))
            x_right = x_left + htf_width
            x_center = x_left + htf_width / 2
            
            // Colors (exact from original)
            is_bullish = candle.c > candle.o
            body_color = is_bullish ? htf_bull_body : htf_bear_body
            border_color = is_bullish ? htf_bull_border : htf_bear_border
            wick_color = is_bullish ? htf_bull_wick : htf_bear_wick
            
            // Delete old objects
            if not na(candle.body)
                box.delete(candle.body)
            if not na(candle.wick_up)
                line.delete(candle.wick_up)
            if not na(candle.wick_down)
                line.delete(candle.wick_down)
            
            // Create candle body (exact from original)
            body_top = math.max(candle.o, candle.c)
            body_bottom = math.min(candle.o, candle.c)
            candle.body := box.new(x_left, body_top, x_right, body_bottom, 
                                  border_color=border_color, bgcolor=body_color, border_width=1)
            
            // Create wicks (exact from original)
            if candle.h > body_top
                candle.wick_up := line.new(x_center, candle.h, x_center, body_top, 
                                          color=wick_color, width=1)
            
            if candle.l < body_bottom
                candle.wick_down := line.new(x_center, body_bottom, x_center, candle.l, 
                                            color=wick_color, width=1)
    
// HTF Label and Timer (updated positioning and real-time updates)
// Calculate highest point of all HTF candles for proper positioning
highest_candle = high
if show_htf_candles and array.size(htf_candles_array) > 0
    for i = 0 to array.size(htf_candles_array) - 1
        candle = array.get(htf_candles_array, i)
        highest_candle := math.max(highest_candle, candle.h)

// HTF Combined Label and Timer (like original: "(11:59) 1H")
if show_htf_candles and (htf_label_show or htf_timer_show)
    var label htf_combined_label = na
    
    // Convert timeframe to readable format
    htf_display_text = htf_timeframe == "60" ? "1H" : 
                      htf_timeframe == "240" ? "4H" : 
                      htf_timeframe == "360" ? "6H" : 
                      htf_timeframe == "720" ? "12H" : 
                      htf_timeframe == "1D" ? "1D" : 
                      htf_timeframe == "1W" ? "1W" : 
                      htf_timeframe == "1M" ? "1M" : htf_timeframe
    
    // Calculate remaining time (exact from original)
    timer_part = if htf_timer_show and barstate.isrealtime
        timeRemaining = (time_close(htf_timeframe) - timenow) / 1000
        days = math.floor(timeRemaining / 86400)
        hours = math.floor((timeRemaining - (days * 86400)) / 3600)
        minutes = math.floor((timeRemaining - (days * 86400) - (hours * 3600)) / 60)
        seconds = math.floor(timeRemaining - (days * 86400) - (hours * 3600) - (minutes * 60))
        
        r = str.tostring(seconds, "00")
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, "00") + ":" + r
        if hours > 0 or days > 0
            r := str.tostring(hours, "00") + ":" + r
        if days > 0
            r := str.tostring(days) + "D " + r
        "(" + r + ")"
    else if htf_timer_show
        "(n/a)"
    else
        ""
    
    // Combine timer and timeframe label
    combined_text = htf_timer_show ? timer_part + "\n" + htf_display_text : htf_display_text
    
    label_x = bar_index + htf_offset + (array.size(htf_candles_array) * (htf_width + htf_buffer)) / 2
    label_y = highest_candle + (highest_candle - low) * 0.08
    
    // Update existing label or create new one
    if not na(htf_combined_label)
        htf_combined_label.set_xy(label_x, label_y)
        htf_combined_label.set_text(combined_text)
    else
        htf_combined_label := label.new(label_x, label_y, combined_text, 
                                       color=htf_label_color, textcolor=color.white, 
                                       style=label.style_label_down, size=htf_label_size)
    




// Auto-Configuration Status (show which timeframes are active)
if barstate.islast
    var table config_table = table.new(position.bottom_right, 2, 6, bgcolor=color.white, border_width=1)
    table.cell(config_table, 0, 0, "Auto-Config Status", text_color=color.white, bgcolor=color.navy, text_size=size.small)
    table.merge_cells(config_table, 0, 0, 1, 0)
    
    // Current chart timeframe
    current_tf_text = timeframe.period
    table.cell(config_table, 0, 1, "Chart TF", text_color=color.black, text_size=size.tiny)
    table.cell(config_table, 1, 1, current_tf_text, text_color=color.blue, text_size=size.tiny)
    
    // Active SMT timeframes (HTF only)
    smt_tf_active = current_tf_seconds <= timeframe.in_seconds("15") ? (smt_tfok1 ? "TF1(1H)" : smt_tfok6 ? "TF6(2H)" : "NONE") :
                   current_tf_seconds <= timeframe.in_seconds("60") ? (smt_tfok2 ? "TF2(4H)" : smt_tfok7 ? "TF7(6H)" : "NONE") :
                   current_tf_seconds <= timeframe.in_seconds("240") ? (smt_tfok4 ? "TF4(1D)" : "NONE") :
                   smt_tfok5 ? "TF5(12H)" : "NONE"
    
    table.cell(config_table, 0, 2, "SMT Source", text_color=color.black, text_size=size.tiny)
    table.cell(config_table, 1, 2, smt_tf_active, text_color=smt_tf_active != "NONE" ? color.green : color.red, text_size=size.tiny)
    
    // CRT timeframes
    crt_active_count = (use_tf1 ? 1 : 0) + (use_tf2 ? 1 : 0) + (use_tf3 ? 1 : 0) + (use_tf4 ? 1 : 0) + (use_tf5 ? 1 : 0)
    table.cell(config_table, 0, 3, "CRT Levels", text_color=color.black, text_size=size.tiny)
    table.cell(config_table, 1, 3, str.tostring(crt_active_count) + " Active", text_color=crt_active_count > 0 ? color.green : color.red, text_size=size.tiny)
    
    // Entry readiness
    config_ready = smt_tf_active != "NONE" and crt_active_count > 0
    table.cell(config_table, 0, 4, "System Status", text_color=color.black, text_size=size.tiny)
    table.cell(config_table, 1, 4, config_ready ? "READY" : "CONFIG NEEDED", text_color=config_ready ? color.green : color.orange, text_size=size.tiny)

// Entry Score Breakdown Table
if show_score_table and barstate.islast
    table_pos = score_table_position == "Top Left" ? position.top_left : score_table_position == "Top Right" ? position.top_right : score_table_position == "Bottom Left" ? position.bottom_left : position.bottom_right
    
    var table score_table = table.new(table_pos, 3, 8, bgcolor=color.white, border_width=1)
    
    // Header
    table.cell(score_table, 0, 0, "Entry Score Breakdown", text_color=color.white, bgcolor=color.navy, text_size=size.normal)
    table.merge_cells(score_table, 0, 0, 2, 0)
    
    // Column headers
    table.cell(score_table, 0, 1, "Signal Type", text_color=color.black, bgcolor=color.gray, text_size=size.small)
    table.cell(score_table, 1, 1, "Points", text_color=color.black, bgcolor=color.gray, text_size=size.small)
    table.cell(score_table, 2, 1, "Active", text_color=color.black, bgcolor=color.gray, text_size=size.small)
    
    // SMT
    table.cell(score_table, 0, 2, "SMT Confirmation", text_color=color.black, text_size=size.tiny)
    table.cell(score_table, 1, 2, str.tostring(smt_points, "#.#"), text_color=color.black, text_size=size.tiny)
    smt_active = (tf1_bull_smt or tf1_bear_smt or tf2_bull_smt or tf2_bear_smt or tf4_bull_smt or tf4_bear_smt or tf5_bull_smt or tf5_bear_smt)
    table.cell(score_table, 2, 2, smt_active ? "✓" : "✗", text_color=smt_active ? color.green : color.red, text_size=size.tiny)
    
    // Double Sweep
    table.cell(score_table, 0, 3, "Double Sweep", text_color=color.black, text_size=size.tiny)
    table.cell(score_table, 1, 3, str.tostring(double_sweep_points, "#.#"), text_color=color.black, text_size=size.tiny)
    // Check for double sweeps based on current timeframe
    double_sweep_active = current_tf_seconds <= timeframe.in_seconds("15") ? (tf1_xl_sweep and tf1_cl_sweep) or (tf1_xh_sweep and tf1_ch_sweep) :
                         current_tf_seconds <= timeframe.in_seconds("60") ? (tf2_xl_sweep and tf2_cl_sweep) or (tf2_xh_sweep and tf2_ch_sweep) :
                         current_tf_seconds <= timeframe.in_seconds("240") ? (tf4_xl_sweep and tf4_cl_sweep) or (tf4_xh_sweep and tf4_ch_sweep) :
                         (tf5_xl_sweep and tf5_cl_sweep) or (tf5_xh_sweep and tf5_ch_sweep)
    table.cell(score_table, 2, 3, double_sweep_active ? "✓" : "✗", text_color=double_sweep_active ? color.green : color.red, text_size=size.tiny)
    
    // CRT Touch
    table.cell(score_table, 0, 4, "CRT Touch/Zone", text_color=color.black, text_size=size.tiny)
    table.cell(score_table, 1, 4, str.tostring(crt_touch_points, "#.#"), text_color=color.black, text_size=size.tiny)
    crt_active = not na(current_crt_high) and not na(current_crt_low)
    table.cell(score_table, 2, 4, crt_active ? "✓" : "✗", text_color=crt_active ? color.green : color.red, text_size=size.tiny)
    
    // CISD
    table.cell(score_table, 0, 5, "CISD Break", text_color=color.black, text_size=size.tiny)
    table.cell(score_table, 1, 5, str.tostring(cisd_points, "#.#"), text_color=color.black, text_size=size.tiny)
    cisd_active = cisd_bullish or cisd_bearish
    table.cell(score_table, 2, 5, cisd_active ? "✓" : "✗", text_color=cisd_active ? color.green : color.red, text_size=size.tiny)
    
    // Single Sweep
    table.cell(score_table, 0, 6, "Single Sweep", text_color=color.black, text_size=size.tiny)
    table.cell(score_table, 1, 6, str.tostring(single_sweep_points, "#.#"), text_color=color.black, text_size=size.tiny)
    // Check for single sweeps based on current timeframe
    single_sweep_active = current_tf_seconds <= timeframe.in_seconds("15") ? (tf1_xl_sweep or tf1_cl_sweep or tf1_xh_sweep or tf1_ch_sweep) and not double_sweep_active :
                         current_tf_seconds <= timeframe.in_seconds("60") ? (tf2_xl_sweep or tf2_cl_sweep or tf2_xh_sweep or tf2_ch_sweep) and not double_sweep_active :
                         current_tf_seconds <= timeframe.in_seconds("240") ? (tf4_xl_sweep or tf4_cl_sweep or tf4_xh_sweep or tf4_ch_sweep) and not double_sweep_active :
                         (tf5_xl_sweep or tf5_cl_sweep or tf5_xh_sweep or tf5_ch_sweep) and not double_sweep_active
    table.cell(score_table, 2, 6, single_sweep_active ? "✓" : "✗", text_color=single_sweep_active ? color.green : color.red, text_size=size.tiny)
    
    // Total Score
    table.cell(score_table, 0, 7, "Total Score", text_color=color.white, bgcolor=color.blue, text_size=size.small)
    table.cell(score_table, 1, 7, str.tostring(signal_str, "#.#"), text_color=color.white, bgcolor=color.blue, text_size=size.small)
    entry_ready = signal_str >= min_entry_score
    table.cell(score_table, 2, 7, entry_ready ? "READY" : "WAIT", text_color=color.white, bgcolor=entry_ready ? color.green : color.red, text_size=size.small)

// Debug info in table (optional)
if show_trade_labels and barstate.islast and not show_score_table
    var table debug_table = table.new(position.top_right, 2, 4, bgcolor=color.white, border_width=1)
    table.cell(debug_table, 0, 0, "CISD Status", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_table, 1, 0, "Value", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_table, 0, 1, "Bullish CISD", text_color=color.black)
    table.cell(debug_table, 1, 1, str.tostring(cisd_bullish), text_color=cisd_bullish ? color.green : color.red)
    table.cell(debug_table, 0, 2, "Bearish CISD", text_color=color.black)
    table.cell(debug_table, 1, 2, str.tostring(cisd_bearish), text_color=cisd_bearish ? color.red : color.green)
    table.cell(debug_table, 0, 3, "Signal Strength", text_color=color.black)
    table.cell(debug_table, 1, 3, str.tostring(signal_str, "#.#"), text_color=color.blue)

//+------------------------------------------------------------------------------------------------------------+//
//+--- 90 CYCLE INTEGRATION                                                                                 ---+//
//+------------------------------------------------------------------------------------------------------------+//

// 90 Cycle Settings
var g_90cycle = "90 Cycle Settings"
enable_90cycle = input.bool(true, "Enable 90 Cycle", group=g_90cycle)
cycle_asia = input.bool(true, "Asia Session", inline="sessions", group=g_90cycle)
cycle_lokz = input.bool(true, "London Session", inline="sessions", group=g_90cycle)
cycle_nyam = input.bool(true, "NY AM Session", inline="sessions", group=g_90cycle)
cycle_nypm = input.bool(true, "NY PM Session", inline="sessions", group=g_90cycle)

cycle_version = input.string("CLS", "Version", options=["Daye", "CLS"], group=g_90cycle)
cycle_line_color = input.color(color.new(color.gray, 69), "Cycle Lines", inline="colors", group=g_90cycle)
cycle_open_color = input.color(color.new(color.orange, 69), "Open Lines", inline="colors", group=g_90cycle)
show_cycle_labels = input.bool(true, "Show Quarter Labels", group=g_90cycle)

// 90 Cycle Logic
var line cycle_open_line = na

if enable_90cycle
    if cycle_version == "Daye"
        if cycle_asia
            if hour(time, timezone="America/New_York") == 18 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 19 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 21 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 22 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
        
        if cycle_asia or cycle_lokz
            if hour(time, timezone="America/New_York") == 00 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
        
        if cycle_lokz
            if hour(time, timezone="America/New_York") == 1 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
                cycle_open_line := line.new(bar_index, open, bar_index+1, open, color=cycle_open_color)
            else if hour(time, timezone="America/New_York") == 3 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 4 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else 
                line.set_x2(cycle_open_line, bar_index)
        
        if cycle_lokz or cycle_nyam
            if hour(time, timezone="America/New_York") == 6 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
        
        if cycle_nyam
            if hour(time, timezone="America/New_York") == 7 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
                cycle_open_line := line.new(bar_index, open, bar_index+1, open, color=cycle_open_color)
            else if hour(time, timezone="America/New_York") == 9 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 10 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else 
                line.set_x2(cycle_open_line, bar_index)
        
        if cycle_nyam or cycle_nypm
            if hour(time, timezone="America/New_York") == 12 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
        
        if cycle_nypm
            if hour(time, timezone="America/New_York") == 13 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
                cycle_open_line := line.new(bar_index, open, bar_index+1, open, color=cycle_open_color)
            else if hour(time, timezone="America/New_York") == 15 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 16 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 18 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else 
                line.set_x2(cycle_open_line, bar_index)
    
    else if cycle_version == "CLS"
        if cycle_lokz
            if hour(time, timezone="America/New_York") == 2 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 4 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 5 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
        
        if cycle_lokz or cycle_nyam
            if hour(time, timezone="America/New_York") == 7 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
        
        if cycle_nyam
            if hour(time, timezone="America/New_York") == 8 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 10 and minute(time, timezone="America/New_York") == 00
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)
            else if hour(time, timezone="America/New_York") == 11 and minute(time, timezone="America/New_York") == 30
                line.new(bar_index, high, bar_index, low, extend=extend.both, color=cycle_line_color)

// 90 Cycle Quarter Labels (Daye version only) - Must be in global scope
// Asia Session Labels
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 18 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q1", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 19 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q2", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 21 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q3", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 22 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q4", char="", size=size.tiny)

// London Session Labels
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 00 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q1", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 01 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q2", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 03 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q3", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 04 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q4", char="", size=size.tiny)

// NY AM Session Labels
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 06 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q1", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 07 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q2", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 09 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q3", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 10 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q4", char="", size=size.tiny)

// NY PM Session Labels
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 12 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q1", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 13 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q2", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 15 and minute(time[1], timezone="America/New_York") == 00, location=location.bottom, color=color.gray, text="q3", char="", size=size.tiny)
plotchar(enable_90cycle and show_cycle_labels and cycle_version == "Daye" and timeframe.in_seconds() < timeframe.in_seconds("60") and hour(time, timezone="America/New_York") == 16 and minute(time[1], timezone="America/New_York") == 30, location=location.bottom, color=color.gray, text="q4", char="", size=size.tiny)

//+------------------------------------------------------------------------------------------------------------+//
//+--- END OF 90 CYCLE INTEGRATION                                                                         ---+//
//+------------------------------------------------------------------------------------------------------------+//